{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OM: Online Data Analysis for X-Ray Imaging What is OM? OM ( O nDA M onitor) is a framework for the development of programs that can monitor x-ray imaging experiments in real-time . It is also a set of ready-to-use monitoring programs. It is the spiritual successor of the OnDA Project and it is maintained mostly by the same team of developers. OM offers a set of stable and efficient real-time monitoring programs for the most common types of x-ray imaging experiments. These can be used immediately without modifications or can be easily adapted to meet the users\u2019 requirements. In addition, the project provides a set of modules that can be used to easily develop other monitoring programs, tailored to the characteristics of specific experiments. OM can process imaging data in the broadest sense : multidimensional pixel-based data (for example: diffraction patterns, photoemission spectrums, images from cameras, microscopes or x-ray detectors), but also any kind of digital output from an instrument or sensor (temperature readouts, beam and pulse energies, etc.). OM focuses on scalability and portability , in order to facilitate its adoption for a wide array of facilities and instruments. It also strives for stability and performance . To achieve these goals, OM processes data in a multi-node parallel environment, using free and open-source libraries and protocols. OM is written in Python . The use of the Python programming language, which is particularly suited to rapid development, makes OM easy to modify and to adapt to the requirements of specific experiments. OM also aims to keep its code base simple and as small . The focus is on providing useful core functionality, while allowing the framework to be expanded with external software. The goal is to avoid re-implementing algorithms that are already better optimized in other software packages. Recommended Citation If you use OM in your experiment, please keep citing the original OnDA paper until a new publication for OM is available: Mariani V., Morgan A., Yoon C.H., Lane T.J., White T.A., O'Grady C., Kuhn M., Aplin S., Koglin J., Barty A., Chapman H.N., OnDA: online data analysis and feedback for serial X-ray imaging. , J. Appl. Crystallogr. 2016 May 23;49(Pt 3):1073-1080. (https://www.ncbi.nlm.nih.gov/pubmed/27275150) Source Code OM is open source software. Its source code is published under the GPLv3 license and can be found on GitHub in the following repository: OM's source code","title":"What is OM?"},{"location":"#om-online-data-analysis-for-x-ray-imaging","text":"","title":"OM: Online Data Analysis for X-Ray Imaging"},{"location":"#what-is-om","text":"OM ( O nDA M onitor) is a framework for the development of programs that can monitor x-ray imaging experiments in real-time . It is also a set of ready-to-use monitoring programs. It is the spiritual successor of the OnDA Project and it is maintained mostly by the same team of developers. OM offers a set of stable and efficient real-time monitoring programs for the most common types of x-ray imaging experiments. These can be used immediately without modifications or can be easily adapted to meet the users\u2019 requirements. In addition, the project provides a set of modules that can be used to easily develop other monitoring programs, tailored to the characteristics of specific experiments. OM can process imaging data in the broadest sense : multidimensional pixel-based data (for example: diffraction patterns, photoemission spectrums, images from cameras, microscopes or x-ray detectors), but also any kind of digital output from an instrument or sensor (temperature readouts, beam and pulse energies, etc.). OM focuses on scalability and portability , in order to facilitate its adoption for a wide array of facilities and instruments. It also strives for stability and performance . To achieve these goals, OM processes data in a multi-node parallel environment, using free and open-source libraries and protocols. OM is written in Python . The use of the Python programming language, which is particularly suited to rapid development, makes OM easy to modify and to adapt to the requirements of specific experiments. OM also aims to keep its code base simple and as small . The focus is on providing useful core functionality, while allowing the framework to be expanded with external software. The goal is to avoid re-implementing algorithms that are already better optimized in other software packages.","title":"What is OM?"},{"location":"#recommended-citation","text":"If you use OM in your experiment, please keep citing the original OnDA paper until a new publication for OM is available: Mariani V., Morgan A., Yoon C.H., Lane T.J., White T.A., O'Grady C., Kuhn M., Aplin S., Koglin J., Barty A., Chapman H.N., OnDA: online data analysis and feedback for serial X-ray imaging. , J. Appl. Crystallogr. 2016 May 23;49(Pt 3):1073-1080. (https://www.ncbi.nlm.nih.gov/pubmed/27275150)","title":"Recommended Citation"},{"location":"#source-code","text":"OM is open source software. Its source code is published under the GPLv3 license and can be found on GitHub in the following repository: OM's source code","title":"Source Code"},{"location":"advanced_documentation/","text":"Advanced Documentation What is OM? OM's focus is on real-time (or quasi-real time) processing of experimental data. Real-time monitoring programs retrieve data from a facility as soon as possible, often immediately after data has been collected, before it is saved to disk. Some fast, simple analysis is usually performed on the data. The goal is to provide enough information to take quick decisions to the people running an experiment. These decisions can often change the direction of the experiment itself while it is still running, adapting it to new conditions and circumstances. Usually, it is not necessary to process all the data being collected in order to provide enough information for the decision making. For example, the hit rate for a Serial Crystallography experiment can be computed with high accuracy by analyzing only a portion of the collected data. It is however crucial that the information provided is up to date. Because of this, OM always prioritizes the processing of recently collected data over the processing of all collected data. Completeness is not the main priority, low latency in providing the information is. Additionally, the goal of OM is strictly to provide quick information to the people running the experiment, not any long-term analysis of the data: after the information is delivered, the data is discarded without being saved to disk, and new data is retrieved. In order to achieve high speed in data processing, OM takes advantage of a multi-node parallel architecture. Several processing units ( processing nodes in OM terminology) retrieve data events (a single frame or a collection of frames presented as a single unit) from a facility, and process them. A collecting node aggregates information from the processing nodes and performs computations over multiple events (averaging, etc.). The reduced data is finally presented the users in the console or sent to external programs for visualization. OM is mostly written using the Python programming language, however, some processing routines are implemented in other languages ( C , C++ ) for performance reasons. Goals of the OM Project The goal of the OM project is to provide users with a collection of modules that can can be used to easily build real-time monitoring programs. However, the project also aims at providing a set of stable and efficient real-time monitors for the most common types of x-ray imaging experiments. These programs can be used immediately without modifications or can be easily adapted to meet the users\u2019 requirements. Currently, only one of these monitoring programs is distributed with OM, focused on Serial Crystallography. Several others are currently under development and will be added as soon as they are ready. The Three Layers In the OM framework, a monitoring program is split into three cleanly separate parts (or Layers , in OM terminology): A part that deals with the retrieval of data from a facility and with the extraction of information from it. This is the Data Retrieval Layer . A part which deals with the running logic of the program (set up and finalization of the processing and collecting nodes, communication between the nodes, etc.). This is called Parallelization Layer . A part that deals with the scientific processing of the extracted data. This is called the Processing Layer . The first two layers are usually different for each facility or beamline. The last layer, however, encodes the logic of the scientific processing of the data. When the same type of monitor is run at different facilities, the same Processing Layer code is run. The interface between the Processing Layer and the other layers is very clearly defined, and the latter layers can be swapped for different implementations without affecting the former. This clean separation is the reason why a developer who wants to write a monitoring program for a supported facility does not need to worry how data is retrieved, or passed around the nodes. All he or she needs to learn is how the data can be accessed and manipulated in the Processing Layer. No knowledge of the other two layers is required. Furthermore, a monitoring program written for a facility can in most cases be run at other facilities just by switching to different implementations of the Data Retrieval and Parallelization layers, keeping the same Processing Layer. OM's Workflow When OM starts, it first initializes all the processing and collecting nodes, on a single or multiple machines, according to the user's wishes. The first process to start on the first machine usually takes the role of the collecting node, while all the others become processing nodes. At start-up, each node reads the configuration file. By default, OM looks for a file called monitor.yaml in the current working directory (or a for a different file specified by the user via a command-line argument). Every node imports the Python modules for the Parallelization, Processing and Data Retrieval layers, as specified in the configuration file. The Data Event Handler and Monitor implementations requested in the configuration file are then retrieved from the DataRetrievalLayer, and Processing Layer respectively. OM can then finally start. The processing nodes start retrieving data events from the data source. After retrieving and unpacking an event, each processing node extracts all the data requested by the configuration file (specified in the required_data entry in the data_retrieval_layer parameter group). It then stores the retrieved data in a Python dictionary and calls the process_data function implemented by the Monitor, passing the dictionary as an argument. When the function finishes running and processing the data, the processing node transmits the returned Python tuple to the collecting node. How the nodes communicate with each other, and which protocol they use to do so (MPI, ZMQ, etc.) is determined by the Parallelization Engine, retrieved on each node from the Processing Layer at startup. Once a processing node has transferred the data to the collecting node, it retrieves the next data event and the cycle begins again. The collecting node executes the collect_data function implemented by the Monitor every time it receives data from a processing node, passing the received tuple as an argument to the function. This process continues indefinitely, or until the data stream ends. In the latter case, some end-of-processing functions, implemented in the Monitor, are called on all nodes. OM then shuts down. Analyzing Data in the Processing Layer Writing a monitoring program consists mainly in writing a Python class (a Monitor class), that lives in the Processing Layer and implements a data analysis pipeline. The whole processing logic should be implemented in this class, which must be a subclass of the OmMonitor abstract class. The Monitor class must implement all the methods that are abstract in the base class. A developer just needs to write the implementation for these methods, but it never needs to call any of them. When OM runs, the methods are automatically called at the right moment, according to the logic described in the Workflow section . The methods are: initialize_processing_node : This function is executed on each processing node when OM starts. All the initialization code for the processing node should go into this function: the relevant class properties should be initialized here. Additionally, code that loads external files (for example, a geometry file, or a file containing a bad pixel mask) should also be placed in this function: the external data should be read and stored in class properties so that the other class methods can access it. initialize_collecting_node : This function is executed on the collecting node when OM starts. This is the equivalent of the previous function for the collecting node, and all initialization code for this type of node should be placed into this function. In particular, network sockets that are later used to broadcast data to external programs are usually opened and initialized in this function. process_data : this function is executed on each processing node when data is retrieved from the data source. The retrieved data gets passed to this function as an argument. All the logic related to the processing of a single data event should be implemented in this method. The output of this function is transferred by OM to the collecting node. Ideally, data should be reduced in this function and the raw, unprocessed information should not be sent to the collecting node. The function must return a tuple, where the first entry is a dictionary containing all the data that should be sent to the collecting node for aggregation, and the second entry is the rank of the processing node sending the data. This allows OM to keep track of which node is transferring the data. collect_data : this function is executed on the collecting node every time data is received from a processing node. The data received from the processing node is passed to this function as an argument. This function should implement all the processing logic that involves more than one event (for example: averaging over many events, accumulation of events, etc.). The developer can choose what to do with the result of the aggregated data processing. There is no fixed path. Often the information is broadcasted to a graphical interface via a network socket, but this is not mandatory. The information could also be, for example, printed on the console. There are two more methods that are not abstract in the base class, but can be overridden to implement some custom end-of-data-processing actions (For example: printing a final summary, etc.). Please note that if OM processes an endless stream of data (for example, most live data streams) these functions are never called. end_processing_on_processing_node : this function is executed on the processing node when OM finishes processing all the data in the data source. The default implementation of this function just prints a message to the console and exits. However, a developer can provide his own implementation, with a different behavior. This function can optionally return data, which is transferred to the collecting node and processed one last time by the collect_data function before OM shuts down. end_processing_on_collection_node : this function is executed on the collecting node when OM finishes processing all data in the data source. The default implementation of this function just prints a message to the console and exits, but a developer can override the default behavior. This function is often used to perform some clean-up task on the collecting node. Tips and Tricks The data being processed should ideally be reduced in the process_data function on each processing node. Transferring large amount of data between the nodes is not efficient and should be avoided whenever possible. For example, when crystallography data is processed and Bragg peaks are extracted from detector frame data, only the list of peaks should be sent to the collecting node. Obviously, this strategy cannot be applied to all cases (a frame viewer GUI, for example, would need the full frame data), but developers should strive to perform as much data reduction as possible on the processing nodes. The Monitor class should be carefully designed and code should be optimized. For example, only variables that need to be accessed from more than one method should become class properties. All others can remain simple local variables. Creating class properties that are not accessed by other methods will clutter the namespace of the class, and can result in performance degradation. Algorithms OM can process data using Algorithms . These are essentially Python classes which implement some data processing logic. Since they are stateful objects, algorithms can be used for operations that must be applied multiple times on different data, but need to keep track of an internal state between applications. For example, the averaging of detector frames can be implemented in OM as an algorithm. The algorithm can keep track of the internal intermediate average, storing it in its internal state, and can update it each time a new detector frame is processed. Algorithms should be used mainly for two types of data processing operations: Operations in which an action defined by the same set of parameters is applied to each data item retrieved by the monitor. In this case, the internal state can be used to store the parameters. A good example of this case is a peak finding algorithm, which is initialized with some parameters and then applied to each frame data retrieved by the monitor. Another good example is a a dark frame correction algorithm, where the same dark calibration data (loaded when the algorithm is initialized) is applied to each retrieved detector frame. Operations in which an action applied to each data item updates the internal state. A good example of this case is an algorithm that computes a running average: every time the algorithm is applied to some new data, the current average, stored in the internal state, is updated. OM provides some pre-packaged algorithms for common data processing operations (peak finding, data accumulation, etc.) in the algorithms sub-package. Tips and Tricks For data processing operations that don't fall in the two cases described above, and do not need to keep track of an internal state, functions can often be used in place of algorithms. For example, the computation of an autocorrelation, the sum of the intensity observed in a detector frame, are both operations that do not need to store any persistent information when applied multiple times. They can be implemented as simple functions instead of algorithms.","title":"Advanced Documentation"},{"location":"advanced_documentation/#advanced-documentation","text":"","title":"Advanced Documentation"},{"location":"advanced_documentation/#what-is-om","text":"OM's focus is on real-time (or quasi-real time) processing of experimental data. Real-time monitoring programs retrieve data from a facility as soon as possible, often immediately after data has been collected, before it is saved to disk. Some fast, simple analysis is usually performed on the data. The goal is to provide enough information to take quick decisions to the people running an experiment. These decisions can often change the direction of the experiment itself while it is still running, adapting it to new conditions and circumstances. Usually, it is not necessary to process all the data being collected in order to provide enough information for the decision making. For example, the hit rate for a Serial Crystallography experiment can be computed with high accuracy by analyzing only a portion of the collected data. It is however crucial that the information provided is up to date. Because of this, OM always prioritizes the processing of recently collected data over the processing of all collected data. Completeness is not the main priority, low latency in providing the information is. Additionally, the goal of OM is strictly to provide quick information to the people running the experiment, not any long-term analysis of the data: after the information is delivered, the data is discarded without being saved to disk, and new data is retrieved. In order to achieve high speed in data processing, OM takes advantage of a multi-node parallel architecture. Several processing units ( processing nodes in OM terminology) retrieve data events (a single frame or a collection of frames presented as a single unit) from a facility, and process them. A collecting node aggregates information from the processing nodes and performs computations over multiple events (averaging, etc.). The reduced data is finally presented the users in the console or sent to external programs for visualization. OM is mostly written using the Python programming language, however, some processing routines are implemented in other languages ( C , C++ ) for performance reasons.","title":"What is OM?"},{"location":"advanced_documentation/#goals-of-the-om-project","text":"The goal of the OM project is to provide users with a collection of modules that can can be used to easily build real-time monitoring programs. However, the project also aims at providing a set of stable and efficient real-time monitors for the most common types of x-ray imaging experiments. These programs can be used immediately without modifications or can be easily adapted to meet the users\u2019 requirements. Currently, only one of these monitoring programs is distributed with OM, focused on Serial Crystallography. Several others are currently under development and will be added as soon as they are ready.","title":"Goals of the OM Project"},{"location":"advanced_documentation/#the-three-layers","text":"In the OM framework, a monitoring program is split into three cleanly separate parts (or Layers , in OM terminology): A part that deals with the retrieval of data from a facility and with the extraction of information from it. This is the Data Retrieval Layer . A part which deals with the running logic of the program (set up and finalization of the processing and collecting nodes, communication between the nodes, etc.). This is called Parallelization Layer . A part that deals with the scientific processing of the extracted data. This is called the Processing Layer . The first two layers are usually different for each facility or beamline. The last layer, however, encodes the logic of the scientific processing of the data. When the same type of monitor is run at different facilities, the same Processing Layer code is run. The interface between the Processing Layer and the other layers is very clearly defined, and the latter layers can be swapped for different implementations without affecting the former. This clean separation is the reason why a developer who wants to write a monitoring program for a supported facility does not need to worry how data is retrieved, or passed around the nodes. All he or she needs to learn is how the data can be accessed and manipulated in the Processing Layer. No knowledge of the other two layers is required. Furthermore, a monitoring program written for a facility can in most cases be run at other facilities just by switching to different implementations of the Data Retrieval and Parallelization layers, keeping the same Processing Layer.","title":"The Three Layers"},{"location":"advanced_documentation/#oms-workflow","text":"When OM starts, it first initializes all the processing and collecting nodes, on a single or multiple machines, according to the user's wishes. The first process to start on the first machine usually takes the role of the collecting node, while all the others become processing nodes. At start-up, each node reads the configuration file. By default, OM looks for a file called monitor.yaml in the current working directory (or a for a different file specified by the user via a command-line argument). Every node imports the Python modules for the Parallelization, Processing and Data Retrieval layers, as specified in the configuration file. The Data Event Handler and Monitor implementations requested in the configuration file are then retrieved from the DataRetrievalLayer, and Processing Layer respectively. OM can then finally start. The processing nodes start retrieving data events from the data source. After retrieving and unpacking an event, each processing node extracts all the data requested by the configuration file (specified in the required_data entry in the data_retrieval_layer parameter group). It then stores the retrieved data in a Python dictionary and calls the process_data function implemented by the Monitor, passing the dictionary as an argument. When the function finishes running and processing the data, the processing node transmits the returned Python tuple to the collecting node. How the nodes communicate with each other, and which protocol they use to do so (MPI, ZMQ, etc.) is determined by the Parallelization Engine, retrieved on each node from the Processing Layer at startup. Once a processing node has transferred the data to the collecting node, it retrieves the next data event and the cycle begins again. The collecting node executes the collect_data function implemented by the Monitor every time it receives data from a processing node, passing the received tuple as an argument to the function. This process continues indefinitely, or until the data stream ends. In the latter case, some end-of-processing functions, implemented in the Monitor, are called on all nodes. OM then shuts down.","title":"OM's Workflow"},{"location":"advanced_documentation/#analyzing-data-in-the-processing-layer","text":"Writing a monitoring program consists mainly in writing a Python class (a Monitor class), that lives in the Processing Layer and implements a data analysis pipeline. The whole processing logic should be implemented in this class, which must be a subclass of the OmMonitor abstract class. The Monitor class must implement all the methods that are abstract in the base class. A developer just needs to write the implementation for these methods, but it never needs to call any of them. When OM runs, the methods are automatically called at the right moment, according to the logic described in the Workflow section . The methods are: initialize_processing_node : This function is executed on each processing node when OM starts. All the initialization code for the processing node should go into this function: the relevant class properties should be initialized here. Additionally, code that loads external files (for example, a geometry file, or a file containing a bad pixel mask) should also be placed in this function: the external data should be read and stored in class properties so that the other class methods can access it. initialize_collecting_node : This function is executed on the collecting node when OM starts. This is the equivalent of the previous function for the collecting node, and all initialization code for this type of node should be placed into this function. In particular, network sockets that are later used to broadcast data to external programs are usually opened and initialized in this function. process_data : this function is executed on each processing node when data is retrieved from the data source. The retrieved data gets passed to this function as an argument. All the logic related to the processing of a single data event should be implemented in this method. The output of this function is transferred by OM to the collecting node. Ideally, data should be reduced in this function and the raw, unprocessed information should not be sent to the collecting node. The function must return a tuple, where the first entry is a dictionary containing all the data that should be sent to the collecting node for aggregation, and the second entry is the rank of the processing node sending the data. This allows OM to keep track of which node is transferring the data. collect_data : this function is executed on the collecting node every time data is received from a processing node. The data received from the processing node is passed to this function as an argument. This function should implement all the processing logic that involves more than one event (for example: averaging over many events, accumulation of events, etc.). The developer can choose what to do with the result of the aggregated data processing. There is no fixed path. Often the information is broadcasted to a graphical interface via a network socket, but this is not mandatory. The information could also be, for example, printed on the console. There are two more methods that are not abstract in the base class, but can be overridden to implement some custom end-of-data-processing actions (For example: printing a final summary, etc.). Please note that if OM processes an endless stream of data (for example, most live data streams) these functions are never called. end_processing_on_processing_node : this function is executed on the processing node when OM finishes processing all the data in the data source. The default implementation of this function just prints a message to the console and exits. However, a developer can provide his own implementation, with a different behavior. This function can optionally return data, which is transferred to the collecting node and processed one last time by the collect_data function before OM shuts down. end_processing_on_collection_node : this function is executed on the collecting node when OM finishes processing all data in the data source. The default implementation of this function just prints a message to the console and exits, but a developer can override the default behavior. This function is often used to perform some clean-up task on the collecting node. Tips and Tricks The data being processed should ideally be reduced in the process_data function on each processing node. Transferring large amount of data between the nodes is not efficient and should be avoided whenever possible. For example, when crystallography data is processed and Bragg peaks are extracted from detector frame data, only the list of peaks should be sent to the collecting node. Obviously, this strategy cannot be applied to all cases (a frame viewer GUI, for example, would need the full frame data), but developers should strive to perform as much data reduction as possible on the processing nodes. The Monitor class should be carefully designed and code should be optimized. For example, only variables that need to be accessed from more than one method should become class properties. All others can remain simple local variables. Creating class properties that are not accessed by other methods will clutter the namespace of the class, and can result in performance degradation.","title":"Analyzing Data in the Processing Layer"},{"location":"advanced_documentation/#algorithms","text":"OM can process data using Algorithms . These are essentially Python classes which implement some data processing logic. Since they are stateful objects, algorithms can be used for operations that must be applied multiple times on different data, but need to keep track of an internal state between applications. For example, the averaging of detector frames can be implemented in OM as an algorithm. The algorithm can keep track of the internal intermediate average, storing it in its internal state, and can update it each time a new detector frame is processed. Algorithms should be used mainly for two types of data processing operations: Operations in which an action defined by the same set of parameters is applied to each data item retrieved by the monitor. In this case, the internal state can be used to store the parameters. A good example of this case is a peak finding algorithm, which is initialized with some parameters and then applied to each frame data retrieved by the monitor. Another good example is a a dark frame correction algorithm, where the same dark calibration data (loaded when the algorithm is initialized) is applied to each retrieved detector frame. Operations in which an action applied to each data item updates the internal state. A good example of this case is an algorithm that computes a running average: every time the algorithm is applied to some new data, the current average, stored in the internal state, is updated. OM provides some pre-packaged algorithms for common data processing operations (peak finding, data accumulation, etc.) in the algorithms sub-package. Tips and Tricks For data processing operations that don't fall in the two cases described above, and do not need to keep track of an internal state, functions can often be used in place of algorithms. For example, the computation of an autocorrelation, the sum of the intensity observed in a detector frame, are both operations that do not need to store any persistent information when applied multiple times. They can be implemented as simple functions instead of algorithms.","title":"Algorithms"},{"location":"configuring_om/","text":"Configuring OM Introduction OM requires at minimum two pieces of information to operate: a source of data events, and a set of configuration parameters. Information about the data source is usually provided as an argument to the monitor\u2019s start up script, in the form of a source string. Configuration parameters, which fully determine the behavior of the monitor, are instead stored in a configuration file that OM reads before starting. The Source String The source string contains information about the origin of the data events that OM will process. The information is encoded in a string that is passed as a command line argument to the om_monitor.py script: om_monitor.py <SOURCE_STRING> The exact format of the string depends on the Data Retrieval Layer implementation used by the monitor, and particularly by the specific Data Event Handler being used. The correct format of the source string is typically part of the information provided to the users by the beamline scientists that configured OM. The source code documentation also provides details on the specific format required by each Data Event Handler. As a rule of thumb, the format of the source string is often tied to the facility where the experiment is taking place. Broadly: LCLS : When OM runs at the LCLS facility, the source string is a psana-style DataSource string. Example: shmem=psana.0:stop=no Local Desktop/Laptop : When OM processes data from files, the source string is usually the relative or absolute path to a file containing a list of data files that OM should process. The data files must be listed one per line in the list file, each with its full relative or absolute path. Example: files.lst The Configuration File The behavior of an OM monitor is completely determined by the content of its configuration file. By default, OM looks for a file called monitor.yaml in the current working directory. However, the --config command line option of the om_monitor.py script allows a custom location for the configuration file to be specified: om_monitor.py --config <PATH_TO_THE_CONFIGURATION_FILE> <SOURCE_STRING> The parameters in the configuration file must be encoded following the rules of the YAML 1.2 language. The parameters are divided into groups. Each group contains a set of parameters that are either related to each other (because they control related features in OM) or apply to the same data processing algorithm. For example: crystallography : broadcast_ip : 127.0.0.1 broadcast_port : 12321 speed_report_interval : 1000 In this example, crystallography is the name of the parameter group, while broadcast_ip , broadcast_port and speed_report_interval are all parameter names. OM's configuration parameters can be required or optional . Required parameters are mandatory and must always be provided. OM usually shows an error and stops if a required parameter is not present in the configuration file. Optional parameters usually control finer behavior of OM or its data processing algorithms and are not strictly required in the configuration file. When an optional parameter is not listed in the file, its default value is usually assumed to be false or null . An alphabetical list of all the configuration parameters, grouped by parameter group, is provided in the following document: List of all parameters and parameters groups A brief description is provided for each parameter. The description clearly states if the parameter is optional or required. Please be aware that depending on which OM monitor is being run, not all the parameter groups need to be present in the configuration file at the same time. Conversely, custom OM monitors might introduce additional parameter and even parameter groups that are not described in the linked document. A missing parameter or parameter group, or the wrong choice of a value for a parameter can cause OM to emit error messages. Please see this paragraph for an in-depth discussion of OM's error reporting.","title":"Configuring OM"},{"location":"configuring_om/#configuring-om","text":"","title":"Configuring OM"},{"location":"configuring_om/#introduction","text":"OM requires at minimum two pieces of information to operate: a source of data events, and a set of configuration parameters. Information about the data source is usually provided as an argument to the monitor\u2019s start up script, in the form of a source string. Configuration parameters, which fully determine the behavior of the monitor, are instead stored in a configuration file that OM reads before starting.","title":"Introduction"},{"location":"configuring_om/#the-source-string","text":"The source string contains information about the origin of the data events that OM will process. The information is encoded in a string that is passed as a command line argument to the om_monitor.py script: om_monitor.py <SOURCE_STRING> The exact format of the string depends on the Data Retrieval Layer implementation used by the monitor, and particularly by the specific Data Event Handler being used. The correct format of the source string is typically part of the information provided to the users by the beamline scientists that configured OM. The source code documentation also provides details on the specific format required by each Data Event Handler. As a rule of thumb, the format of the source string is often tied to the facility where the experiment is taking place. Broadly: LCLS : When OM runs at the LCLS facility, the source string is a psana-style DataSource string. Example: shmem=psana.0:stop=no Local Desktop/Laptop : When OM processes data from files, the source string is usually the relative or absolute path to a file containing a list of data files that OM should process. The data files must be listed one per line in the list file, each with its full relative or absolute path. Example: files.lst","title":"The Source String"},{"location":"configuring_om/#the-configuration-file","text":"The behavior of an OM monitor is completely determined by the content of its configuration file. By default, OM looks for a file called monitor.yaml in the current working directory. However, the --config command line option of the om_monitor.py script allows a custom location for the configuration file to be specified: om_monitor.py --config <PATH_TO_THE_CONFIGURATION_FILE> <SOURCE_STRING> The parameters in the configuration file must be encoded following the rules of the YAML 1.2 language. The parameters are divided into groups. Each group contains a set of parameters that are either related to each other (because they control related features in OM) or apply to the same data processing algorithm. For example: crystallography : broadcast_ip : 127.0.0.1 broadcast_port : 12321 speed_report_interval : 1000 In this example, crystallography is the name of the parameter group, while broadcast_ip , broadcast_port and speed_report_interval are all parameter names. OM's configuration parameters can be required or optional . Required parameters are mandatory and must always be provided. OM usually shows an error and stops if a required parameter is not present in the configuration file. Optional parameters usually control finer behavior of OM or its data processing algorithms and are not strictly required in the configuration file. When an optional parameter is not listed in the file, its default value is usually assumed to be false or null . An alphabetical list of all the configuration parameters, grouped by parameter group, is provided in the following document: List of all parameters and parameters groups A brief description is provided for each parameter. The description clearly states if the parameter is optional or required. Please be aware that depending on which OM monitor is being run, not all the parameter groups need to be present in the configuration file at the same time. Conversely, custom OM monitors might introduce additional parameter and even parameter groups that are not described in the linked document. A missing parameter or parameter group, or the wrong choice of a value for a parameter can cause OM to emit error messages. Please see this paragraph for an in-depth discussion of OM's error reporting.","title":"The Configuration File"},{"location":"data/","text":"Data Types Available For Each Data Event Handler CxiLclsCspadDataEventHandler Available data types: beam_energy detector_distance detector_data digitizer_data event_id frame_id optical_laser_active opal_data timestamp timetool_data xrays_active CxiLclsDataEventHandler Available data types: beam_energy detector_distance detector_data digitizer_data event_id frame_id optical_laser_active opal_data timestamp timetool_data xrays_active Jungfrau1MFilesDataEventHandler Available data types: beam_energy detector_data detector_distance event_id frame_id timestamp MfxLclsDataEventHandler Available data types: beam_energy detector_distance detector_data digitizer_data event_id frame_id optical_laser_active opal_data timestamp timetool_data xrays_active MfxLclsRayonixEventHandler Available data types: beam_energy detector_distance detector_data digitizer_data event_id frame_id optical_laser_active opal_data timestamp timetool_data xrays_active PilatusFilesDataEventHandler Available data types: beam_energy detector_data detector_distance event_id frame_id timestamp","title":"Available Data Types For Each Data Event Handler"},{"location":"data/#data-types-available-for-each-data-event-handler","text":"","title":"Data Types Available For Each Data Event Handler"},{"location":"data/#cxilclscspaddataeventhandler","text":"Available data types: beam_energy detector_distance detector_data digitizer_data event_id frame_id optical_laser_active opal_data timestamp timetool_data xrays_active","title":"CxiLclsCspadDataEventHandler"},{"location":"data/#cxilclsdataeventhandler","text":"Available data types: beam_energy detector_distance detector_data digitizer_data event_id frame_id optical_laser_active opal_data timestamp timetool_data xrays_active","title":"CxiLclsDataEventHandler"},{"location":"data/#jungfrau1mfilesdataeventhandler","text":"Available data types: beam_energy detector_data detector_distance event_id frame_id timestamp","title":"Jungfrau1MFilesDataEventHandler"},{"location":"data/#mfxlclsdataeventhandler","text":"Available data types: beam_energy detector_distance detector_data digitizer_data event_id frame_id optical_laser_active opal_data timestamp timetool_data xrays_active","title":"MfxLclsDataEventHandler"},{"location":"data/#mfxlclsrayonixeventhandler","text":"Available data types: beam_energy detector_distance detector_data digitizer_data event_id frame_id optical_laser_active opal_data timestamp timetool_data xrays_active","title":"MfxLclsRayonixEventHandler"},{"location":"data/#pilatusfilesdataeventhandler","text":"Available data types: beam_energy detector_data detector_distance event_id frame_id timestamp","title":"PilatusFilesDataEventHandler"},{"location":"errors/","text":"OM's Errors And Warnings This document contains a list of the most common errors reported by OM, with a brief discussion of each. OmConfigurationFileReadingError There was a problem finding or reading the configuration file. The file should exist and be readable. OM looks by default for a file called monitor.yaml in the current working directory. OmConfigurationFileSyntaxError There is a syntax error in the configuration file, at the location specified by the error. The file should follow the YAML 1.2 language syntax. OmDataExtractionError An error has happened during the extraction of data from a data event. This error is usually not fatal and can happen often if the data stream is corrupted. Usually OM skips processing the event and retrieves a new one. OmHdf5FileReadingError An error has happened while reading an HDF5 file. The file should exists and be readable. OmInvalidDataBroadcastUrl The format of the data_broadcast_url parameter in the crystallography section of the configuration file is not valid. The parameter should either have the format tcp://hostname:port or the format ipc:///path/to/socket . Additionally, if the IPC protocol is used, OM must have the correct permissions to access the ipc socket. OmInvalidSourceError The format of the source string is not valid. There could be typos in the string or the format of the string might not match the facility where OM is running. OmMissingDependencyError One of the optional Python module needed by OM is not installed. This error often happens with python modules that are tied to a specific facility's framework (for example, the psana module). One of the core developers should be contacted. OmMissingDataExtractionFunctionError One of the Data Extraction Functions is not defined in the Data Retrieval Layer. One of the core developers should be contacted. OmMissingHdf5PathError An internal path in the HDF5 file is not found. The file exists and can be read, but the internal path cannot be found. The internal HDF5 path is probably incorrect, or the file is corrupted. OmMissingParameterError A required parameter is missing from the configuration file. OmMissingParameterGroupError A parameter group is missing from the configuration file. OmWrongParameterTypeError The type of the parameter in the configuration file does not match the requested one. The type (string, float, int) of the parameter in the configuration file is probably incorrect. The configuration file must strictly follow the YAML 1.2 language specification.","title":"OM's Error Messages"},{"location":"errors/#oms-errors-and-warnings","text":"This document contains a list of the most common errors reported by OM, with a brief discussion of each. OmConfigurationFileReadingError There was a problem finding or reading the configuration file. The file should exist and be readable. OM looks by default for a file called monitor.yaml in the current working directory. OmConfigurationFileSyntaxError There is a syntax error in the configuration file, at the location specified by the error. The file should follow the YAML 1.2 language syntax. OmDataExtractionError An error has happened during the extraction of data from a data event. This error is usually not fatal and can happen often if the data stream is corrupted. Usually OM skips processing the event and retrieves a new one. OmHdf5FileReadingError An error has happened while reading an HDF5 file. The file should exists and be readable. OmInvalidDataBroadcastUrl The format of the data_broadcast_url parameter in the crystallography section of the configuration file is not valid. The parameter should either have the format tcp://hostname:port or the format ipc:///path/to/socket . Additionally, if the IPC protocol is used, OM must have the correct permissions to access the ipc socket. OmInvalidSourceError The format of the source string is not valid. There could be typos in the string or the format of the string might not match the facility where OM is running. OmMissingDependencyError One of the optional Python module needed by OM is not installed. This error often happens with python modules that are tied to a specific facility's framework (for example, the psana module). One of the core developers should be contacted. OmMissingDataExtractionFunctionError One of the Data Extraction Functions is not defined in the Data Retrieval Layer. One of the core developers should be contacted. OmMissingHdf5PathError An internal path in the HDF5 file is not found. The file exists and can be read, but the internal path cannot be found. The internal HDF5 path is probably incorrect, or the file is corrupted. OmMissingParameterError A required parameter is missing from the configuration file. OmMissingParameterGroupError A parameter group is missing from the configuration file. OmWrongParameterTypeError The type of the parameter in the configuration file does not match the requested one. The type (string, float, int) of the parameter in the configuration file is probably incorrect. The configuration file must strictly follow the YAML 1.2 language specification.","title":"OM's Errors And Warnings"},{"location":"geometry/","text":"Example Geometry Files for X-Ray Detectors X-Ray Detectors Used at the LCLS Facility Epix10k2M Jungfrau4M Rayonix X-Ray Detectors Used at the PETRA-III Facility Pilatus","title":"Example Geometry Files"},{"location":"geometry/#example-geometry-files-for-x-ray-detectors","text":"","title":"Example Geometry Files for X-Ray Detectors"},{"location":"geometry/#x-ray-detectors-used-at-the-lcls-facility","text":"Epix10k2M Jungfrau4M Rayonix","title":"X-Ray Detectors Used at the LCLS Facility"},{"location":"geometry/#x-ray-detectors-used-at-the-petra-iii-facility","text":"Pilatus","title":"X-Ray Detectors Used at the PETRA-III Facility"},{"location":"installing_om/","text":"Installing OM OM at Facilities OM comes pre-installed at some beamlines and facilities. At the LCLS facility, OM is already installed at the following beamlines: MFX beamline CXI beamline OM can be used directly at at these beamlines and facilities. However, the users should always notify in advance the beamline scientists at each facility of their intention to use OM during an experiment. OM on a Laptop/Desktop There are three ways to instal OM on a standalone Desktop/Laptop computer. Installation from PyPI OM is available on PiPY: OM on PyPI It can be installed using the pip command: pip install ondamonitor Installation from CondaForge OM is available in the CondaForge package collection and can be installed using the conda install command: conda install -c conda-forge ondamonitor Installation from Source OM can be also be installed from source. As a first step, the source code should be retrieved from GitHub. A compressed code archive for each stable release can be found the following page: OM's release archives Alternatively, the source code can be retrieved directly from the GitHub repository using the git clone command: git clone https://github.com/omdevteam/om OM can then be installed using the pip command from the root directory of the retrieved source code (the directory that contains the setup.py file): pip install --prefix = <INSTALLATION PATH> . In this command, <INSTALLATION PATH> is a relative or absolute path to the directory where OM should be installed. A Python development-style installation can also be performed using the pip command: pip install --editable --prefix = <INSTALLATION PATH> . When OM is installed from source, some additional configuration is needed for the local operating system to subsequently find the installation directory. Typically, on Linux, the following environment variables need to be set: export PATH = <INSTALLATION PATH>/bin: $PATH export PYTHONPATH = <INSTALLATION PATH>/lib/python<PYVER>/site-packages: $PYTHONPATH Here, <INSTALLATION_PATH> is the directory where OM has been installed, and <PYVER> is the version of Python used by the system (only the major and minor components of the version number). The Python version number can be obtained using the python -V command, which outputs a string in the following format: Python X.Y.Z . The <PYVER> entry in the command above corresponds to the X.Y part of this string. Installation Script OM can also be installed from source using a script that is provided with the source code: sh tools/script/install.sh The script allows the installation of OM at a custom path, and supports editable Python installations. The script can install OM with all its base dependencies or, if a Python environment already provides them, it can also simply install OM. A list of all options supported by the script can be obtained using the following command: sh tools/script/install.sh -h In addition to installing OM, the script also creates a file that can be used to activate the installation and set all the required environment variables. If a specific installation of OM has been carried out by the install.sh script, it can be activated by sourcing the file generated by the script: source <INSTALLATION PATH>/bin/activate Where, <INSTALLATION_PATH> is the directory where OM has been installed. MPI When using OM's MPI Parallelization Engine (the default Parallelization Engine), an MPI framework must be installed on the system where OM is launched. The most popular choices are OpenMPI and MPICH. OpenMPI MPICH The precise instructions for the installation of these frameworks are complex, operating system-dependent, and outside of the scope of this documentation. Please note that in addition to one of the MPI frameworks, the corresponding mpi4py module for the Python interpreter used by OM must also be installed.","title":"Installing OM"},{"location":"installing_om/#installing-om","text":"","title":"Installing OM"},{"location":"installing_om/#om-at-facilities","text":"OM comes pre-installed at some beamlines and facilities. At the LCLS facility, OM is already installed at the following beamlines: MFX beamline CXI beamline OM can be used directly at at these beamlines and facilities. However, the users should always notify in advance the beamline scientists at each facility of their intention to use OM during an experiment.","title":"OM at Facilities"},{"location":"installing_om/#om-on-a-laptopdesktop","text":"There are three ways to instal OM on a standalone Desktop/Laptop computer.","title":"OM on a Laptop/Desktop"},{"location":"installing_om/#installation-from-pypi","text":"OM is available on PiPY: OM on PyPI It can be installed using the pip command: pip install ondamonitor","title":"Installation from PyPI"},{"location":"installing_om/#installation-from-condaforge","text":"OM is available in the CondaForge package collection and can be installed using the conda install command: conda install -c conda-forge ondamonitor","title":"Installation from CondaForge"},{"location":"installing_om/#installation-from-source","text":"OM can be also be installed from source. As a first step, the source code should be retrieved from GitHub. A compressed code archive for each stable release can be found the following page: OM's release archives Alternatively, the source code can be retrieved directly from the GitHub repository using the git clone command: git clone https://github.com/omdevteam/om OM can then be installed using the pip command from the root directory of the retrieved source code (the directory that contains the setup.py file): pip install --prefix = <INSTALLATION PATH> . In this command, <INSTALLATION PATH> is a relative or absolute path to the directory where OM should be installed. A Python development-style installation can also be performed using the pip command: pip install --editable --prefix = <INSTALLATION PATH> . When OM is installed from source, some additional configuration is needed for the local operating system to subsequently find the installation directory. Typically, on Linux, the following environment variables need to be set: export PATH = <INSTALLATION PATH>/bin: $PATH export PYTHONPATH = <INSTALLATION PATH>/lib/python<PYVER>/site-packages: $PYTHONPATH Here, <INSTALLATION_PATH> is the directory where OM has been installed, and <PYVER> is the version of Python used by the system (only the major and minor components of the version number). The Python version number can be obtained using the python -V command, which outputs a string in the following format: Python X.Y.Z . The <PYVER> entry in the command above corresponds to the X.Y part of this string.","title":"Installation from Source"},{"location":"installing_om/#installation-script","text":"OM can also be installed from source using a script that is provided with the source code: sh tools/script/install.sh The script allows the installation of OM at a custom path, and supports editable Python installations. The script can install OM with all its base dependencies or, if a Python environment already provides them, it can also simply install OM. A list of all options supported by the script can be obtained using the following command: sh tools/script/install.sh -h In addition to installing OM, the script also creates a file that can be used to activate the installation and set all the required environment variables. If a specific installation of OM has been carried out by the install.sh script, it can be activated by sourcing the file generated by the script: source <INSTALLATION PATH>/bin/activate Where, <INSTALLATION_PATH> is the directory where OM has been installed.","title":"Installation Script"},{"location":"installing_om/#mpi","text":"When using OM's MPI Parallelization Engine (the default Parallelization Engine), an MPI framework must be installed on the system where OM is launched. The most popular choices are OpenMPI and MPICH. OpenMPI MPICH The precise instructions for the installation of these frameworks are complex, operating system-dependent, and outside of the scope of this documentation. Please note that in addition to one of the MPI frameworks, the corresponding mpi4py module for the Python interpreter used by OM must also be installed.","title":"MPI"},{"location":"parameters/","text":"OM's Configuration Parameters This document provides a list of all of OM's configuration parameters, sorted by parameter group, with a brief description of each. correction This parameter group contains parameters that control how OM applies corrections on detector data frames using the Correction algorithm. dark_filename (str or None) The relative or absolute path to an HDF5 file containing a dark data frame. If this and the dark_hdf5_path parameters are not None , the dark data is loaded and applied to the detector frame. Example: run21_dark.h5 dark_hdf5_path (str or None) The internal HDF5 path to the data block where the dark data frame is located. If the dark_filename parameter is not None , this parameter must also be provided, and cannot be None . Otherwise it is ignored. Example: /data/data gain_filename (str or None) The relative or absolute path to an HDF5 file containing a gain map. If this and the gain_hdf5_path parameters are not None , the gain map is loaded and applied to the detector frame. Each pixel in the gain map must store the gain factor that will be applied to the corresponding pixel in the detector frame. Example: files/cspad_gain_map.h5 gain_hdf5_path (str or None) The internal HDF5 path to the data block where the gain map data is located. If the gain_filename parameter is not None , this parameter must also be provided, and cannot be None . Otherwise it is ignored. Example: /data/data mask_filename (str or None) The relative or absolute path to an HDF5 file containing a mask. If this and the mask_hdf5_path parameters are not None , the mask is loaded and applied to the detector frame. The pixels in the mask must have a value of either 0, meaning that the corresponding pixel in the detector frame must be set to 0, or 1, meaning that the value of the corresponding pixel must be left alone. Example: files/run18_mask.h5 mask_hdf5_path (str or None) The internal HDF5 path to the data block where the mask data is located. If the mask_filename parameter is not None , this parameter must also be provided, and cannot be None . Otherwise it is ignored. Example: /data/data crystallography This parameter group contains parameters used specifically by the OnDA Monitor for Crystallography. data_broadcast_url (str or None) The URL of the socket where OM broadcasts data to external programs. The parameter should have the format tcp://hostname:port or the format ipc:///path/to/socket , depending on the protocol used for the broadcast. If the value of this parameter is None , the TCP protocol is used by default, the IP address of the host is detected automatically and the broadcast URL is set to tcp://<IP_ADDRESS>:12321 . Example: tcp://127.0.0.1:8080 geometry_file (str) The absolute or relative path to a geometry file in CrystFEL format . Example: files/pilatus.geom geometry_is_optimized (bool) Whether the detector geometry is optimized. This information is broadcast by the monitor and can be used by external programs. For example, the Crystallography GUI uses this information to decide if the resolution rings should be displayed or not (if the geometry is not optimized, the rings are not reliable). Example: false hit_frame_sending_interval (int or None) This parameter determines how often the monitor sends full detector frames (as opposed to reduced data) to external programs. It only applies to frames that have not been labelled as hits. If the value of this parameter is None , no hit frames are ever sent. If the value is a number, it is the number of hit frames that each processing node skips before sending the next frame to the collecting node to be broadcast. If, for example, the value of this parameter is 5, each processing node sends every 5th hit frame to the collecting node for broadcasting. Example: 10 max_num_peaks_for_hit (int) The maximum number of Bragg peaks that must be found in a detector frame for the frame to be labelled as a hit. Example: 500 min_num_peaks_for_hit (int) The minimum number of Bragg peaks that need to be found in a detector frame for the frame to be labelled as a hit. Example: 10 non_hit_frame_sending_interval (int or None) This parameter determines how often the monitor sends full detector frames (as opposed to reduced data) to external programs. It only applies to frames that have not been labelled as hits. If the value of this parameter is None , no non-hit frames are ever sent. If value is a number, it is the number of non-hit frames that each processing node skips before sending the next frame to the collecting node to be broadcast. If, for example, the value of this parameter is 100, each processing node sends every 100th non-hit frame to the collecting node for broadcasting. Example: 1000 running_average_window_size (int) The size of the running window used by the monitor to compute the average hit rate . OM computes the average rate over the number of most recent events specified by this parameter. Example: 100 speed_report_interval (int) The number of events that must pass between consecutive speed reports from OM. This parameter determines how often OM prints the \"Processed: ...\" message that provides information for about the processing speed. Example: 100 data_broadcast_interval (int) The number of events that must pass between consecutive data broadcasts from OM. This parameter determines how often OM sends data to external programs. It should not be set to a value that is too low: if data is transferred too frequently, the network bandwidth could be saturated and OM could interfere with other running applications. Example: 120 data_retrieval_layer This parameter group contains parameters that control OM's Data Retrieval Layer, influencing the way OM retrieves data events from the data source (a file, a facility framework, etc.). Please note that some parameters apply to all Data Event Handlers, while others only apply to a subset of Handlers, or have different meaning for different Handlers. Warning Please exercise caution when changing the values of the parameters in this group: a wrong choice can severely impact data retrieval and result in OM not working correctly. All Data Event Handlers The parameters in this subsection apply to all Data Event Handlers required_data (List[str]) The data that the current monitor should retrieve for each event. For each type of data listed here, an extraction function must be available for the Data Event Handler that OM is currently using. If this condition is met, the data will be retrieved and made available for processing, otherwise an error will be raised an OM will stop running. For a list of all data types that each Data Event Handler can currently retrieve, please see the following document: List of data types available for each Data Event Handler Example: [detector_data, detector_distance, beam_energy, timestamp] Psana-based Data Event Handlers The parameters in this section apply only to the psana-based Data Event Handlers, specifically: CxiLclsDataEventHandler CxiLclsCspadDataEventHandler MfxLclsDataEventHandler MfxLclsRayonixDataEventHandler active_optical_laser_evr_code (int) EVR event code corresponding to an active optical laser. To determine if the optical laser is active, OM checks if the code provided by this parameter matches one of the EVR event codes associated with the current event. Example: 92 active_xray_evr_code (int) EVR event code corresponding to the x-rays being active. To determine if the x-rays are active, OM checks if the code provided by this parameter matches one of the EVR event codes associated with the current event. Example: 42 calibration (bool) Whether to retrieve calibrated or non calibrated x-ray detector data from psana. This parameter switches on and off the internal calibration provided by psana. Example: true psana_calibration_directory (str) The path to the directory where psana stores all calibration information for the current experiment. Example: /reg/d/psdm/mfx/mfxc00118/calib psana_detector_name (str) The name of the main x-ray detector from which psana retrieves data. Example: DscCsPad psana_detector_distance_epics_name (str) The name of the Epics variable from which psana retrieves detector distance information for the main x-ray detector. Example: CXI:DS1:MMS:06.RBV psana_digitizer_name (str) The name of the main digitizer device from which psana retrieves information. Example: Acqiris psana_evr_source_name (str) The name of the EVR source from which psana retrieves information. Example: evr0 psana_opal_name (str) The name of the Opal camera from which psana retrieves information. Example: Opal1 psana_timetool_epics_name (str) The name of the Epics variable from which psana retrieves timetool information. Example: CXI:DS1:MMS:06.RBV Filesystem-based Data Event Handlers The parameters in this section apply only to the file-based Data Event Handlers, and specifically to the following Handlers: PilatusFilesDataEventHandler JungFrau1MDataEventHandler calibration(bool) Whether to calibrate the retrieved x-ray detector data or not. When reading from files, the calibration of the detector data is usually performed by OM. OM often needs external information to perform the calibration, and retrieves it from a set of files defined by the calibration_dark_filenames and calibration_gain_filenames parameters. In some cases, additional parameters (for example calibration_photon_energy_kev ) must also be provided to further define the calibration process. Example: true calibration_dark_filenames (Union[str, List[str]]) File or list of files containing dark frame information for the calibration of x-ray detector data. If dark frame information is needed by the detector being calibrated, OM will read the information from the files specified by this parameter. If, however, the calibration is not performed or if the Data Event Handler does not need dark frame information for the calibration, this parameter is ignored. Example: dark_info.h5 or [dark_info_panel0.h5, dark_info_panel1.h5] calibration_gain_filenames (Union[str, List[str]]) File or list of files containing gain information for the calibration of x-ray detector data. If gain information is needed by the detector being calibrated, OM will read the information from the files specified by this parameter. If, however, the calibration is not performed or if the Data Event Handler does not need gain information for the calibration, this parameter is ignored. Example: gain_info.h5 or [gain_info_panel0.h5, gain_info_panel1.h5] calibration_photon_energy_kev (float) The photon energy for which the x-ray detector data should be calibrated. The exact values of the calibration constants for a detector often depend on the photon energy at which the detector is operated. If a calibration algorithm needs this information, OM will take the value provided by this parameter. If, however, the calibration is not performed or if the Data Event Handler does not need this kind of information for the calibration, this parameter is ignored. Example: 9.1 fallback_beam_energy_in_eV (float) The beam energy in eV . OM uses this fallback value when the the relevant information is not present in the data files. Example: 12000 fallback_detector_distance_in_mm (float) The detector distance in mm . OM uses this fallback value when the the relevant information is not present in the data files. Example: 250 num_frames_in_event_to_process (int) The number of frames in an event that OM should process. Sometimes data events contain multiple frames but OM does not need to process them all. This parameter specifies how many frames OM should consider. Please note that OM will give precedence to the frames in the event that were collected more recently. If, for example, this parameter specifies that OM should process n frames, OM will process the last n frames in the event. Example: 1 om Warning This section determines the core behavior of the OM monitor. The value of these parameters should be changed only by an expert. A wrong parameter choice is likely to leave OM in a non-working state. data_event_handler (str) The name of the class implementing the Data Event Handler currently used by OM. The class should be defined in the Data Retrieval Layer module file specified by the data_retrieval_layer parameter in this group. Example: MfxLclsDataEventHandler data_retrieval_layer (str) The name of the python module with the implementation of the Data Retrieval Layer currently used by OM. Example: data_handlers_psana monitor (str) The name of the class implementing the Monitor currently used by OM. The class should be defined in the Processing Layer module file specified by the processing_layer parameter in this group. Example: Crystallography parallelization_engine (str) The name of the class implementing the Parallelization Engine currently used by OM. The class should be defined in the Parallelization Layer module file specified by the parallelization_layer parameter in this group. Example: MpiParallelizationEngine parallelization_layer (str) The name of the python module with the implementation of the Parallelization Layer currently used by OM. Example: mpi processing_layer (str) The name of the python module with the implementation of the Processing Layer currently used by OM. Example: crystallography peakfinder8_peak_detection This parameter group contains parameters that control how OM performs peak finding on a detector data frame using the Peakfinder8PeakDetection algorithm. adc_threshold (float) The minimum ADC threshold for peak detection. Example: 200 bad_pixel_map_filename (str or None) The absolute or relative path to an HDF5 file containing a bad pixel map. The map is used to mark areas of the data frame that must be excluded from the peak search. Each pixel in the map must have a value of either 0, meaning that the corresponding pixel in the data frame must be ignored, or 1, meaning that the corresponding pixel must be included in the search. The map is only used to exclude areas from the peak search: the data is not modified in any way. If the value of these parameter is None , no area is excluded from the peak search. Example: bad_pixel_mask.h5 bad_pixel_map_hdf5_path (str or None) The internal HDF5 path to the data block where the bad pixel map is stored. If the value of the bad_pixel_map_filename parameter is not None , this parameter must also be provided, and cannot be None . Otherwise it is ignored. Example: /data/data detector_type (str) The type of detector on which the peak finding algorithm will be applied. The detector types currently supported are: cspad pilatus jungfrau1M jungfrau4M epix10k2M Rayonix Example: cspad max_num_peaks (int) The maximum number of peaks that will be retrieved from each detector data frame. Additional peaks will be ignored. Example: 2048 local_bg_radius (int) The radius (in pixels) for the estimation of the local background. Example: 3 max_pixel_count (int) The maximum size of a peak in pixels. Example: 10 max_res (int) The maximum resolution (in pixels) at which a peak will be found. Example: 800 min_pixel_count (int) The minimum size of a peak in pixels. Example: 1 minimum_snr (float) The minimum signal-to-noise ratio for peak detection. Example: 5.0 min_res (int): The minimum resolution for a peak in pixels. Example: 20","title":"OM's Configuration Parameters"},{"location":"parameters/#oms-configuration-parameters","text":"This document provides a list of all of OM's configuration parameters, sorted by parameter group, with a brief description of each.","title":"OM's Configuration Parameters"},{"location":"parameters/#correction","text":"This parameter group contains parameters that control how OM applies corrections on detector data frames using the Correction algorithm. dark_filename (str or None) The relative or absolute path to an HDF5 file containing a dark data frame. If this and the dark_hdf5_path parameters are not None , the dark data is loaded and applied to the detector frame. Example: run21_dark.h5 dark_hdf5_path (str or None) The internal HDF5 path to the data block where the dark data frame is located. If the dark_filename parameter is not None , this parameter must also be provided, and cannot be None . Otherwise it is ignored. Example: /data/data gain_filename (str or None) The relative or absolute path to an HDF5 file containing a gain map. If this and the gain_hdf5_path parameters are not None , the gain map is loaded and applied to the detector frame. Each pixel in the gain map must store the gain factor that will be applied to the corresponding pixel in the detector frame. Example: files/cspad_gain_map.h5 gain_hdf5_path (str or None) The internal HDF5 path to the data block where the gain map data is located. If the gain_filename parameter is not None , this parameter must also be provided, and cannot be None . Otherwise it is ignored. Example: /data/data mask_filename (str or None) The relative or absolute path to an HDF5 file containing a mask. If this and the mask_hdf5_path parameters are not None , the mask is loaded and applied to the detector frame. The pixels in the mask must have a value of either 0, meaning that the corresponding pixel in the detector frame must be set to 0, or 1, meaning that the value of the corresponding pixel must be left alone. Example: files/run18_mask.h5 mask_hdf5_path (str or None) The internal HDF5 path to the data block where the mask data is located. If the mask_filename parameter is not None , this parameter must also be provided, and cannot be None . Otherwise it is ignored. Example: /data/data","title":"correction"},{"location":"parameters/#crystallography","text":"This parameter group contains parameters used specifically by the OnDA Monitor for Crystallography. data_broadcast_url (str or None) The URL of the socket where OM broadcasts data to external programs. The parameter should have the format tcp://hostname:port or the format ipc:///path/to/socket , depending on the protocol used for the broadcast. If the value of this parameter is None , the TCP protocol is used by default, the IP address of the host is detected automatically and the broadcast URL is set to tcp://<IP_ADDRESS>:12321 . Example: tcp://127.0.0.1:8080 geometry_file (str) The absolute or relative path to a geometry file in CrystFEL format . Example: files/pilatus.geom geometry_is_optimized (bool) Whether the detector geometry is optimized. This information is broadcast by the monitor and can be used by external programs. For example, the Crystallography GUI uses this information to decide if the resolution rings should be displayed or not (if the geometry is not optimized, the rings are not reliable). Example: false hit_frame_sending_interval (int or None) This parameter determines how often the monitor sends full detector frames (as opposed to reduced data) to external programs. It only applies to frames that have not been labelled as hits. If the value of this parameter is None , no hit frames are ever sent. If the value is a number, it is the number of hit frames that each processing node skips before sending the next frame to the collecting node to be broadcast. If, for example, the value of this parameter is 5, each processing node sends every 5th hit frame to the collecting node for broadcasting. Example: 10 max_num_peaks_for_hit (int) The maximum number of Bragg peaks that must be found in a detector frame for the frame to be labelled as a hit. Example: 500 min_num_peaks_for_hit (int) The minimum number of Bragg peaks that need to be found in a detector frame for the frame to be labelled as a hit. Example: 10 non_hit_frame_sending_interval (int or None) This parameter determines how often the monitor sends full detector frames (as opposed to reduced data) to external programs. It only applies to frames that have not been labelled as hits. If the value of this parameter is None , no non-hit frames are ever sent. If value is a number, it is the number of non-hit frames that each processing node skips before sending the next frame to the collecting node to be broadcast. If, for example, the value of this parameter is 100, each processing node sends every 100th non-hit frame to the collecting node for broadcasting. Example: 1000 running_average_window_size (int) The size of the running window used by the monitor to compute the average hit rate . OM computes the average rate over the number of most recent events specified by this parameter. Example: 100 speed_report_interval (int) The number of events that must pass between consecutive speed reports from OM. This parameter determines how often OM prints the \"Processed: ...\" message that provides information for about the processing speed. Example: 100 data_broadcast_interval (int) The number of events that must pass between consecutive data broadcasts from OM. This parameter determines how often OM sends data to external programs. It should not be set to a value that is too low: if data is transferred too frequently, the network bandwidth could be saturated and OM could interfere with other running applications. Example: 120","title":"crystallography"},{"location":"parameters/#data_retrieval_layer","text":"This parameter group contains parameters that control OM's Data Retrieval Layer, influencing the way OM retrieves data events from the data source (a file, a facility framework, etc.). Please note that some parameters apply to all Data Event Handlers, while others only apply to a subset of Handlers, or have different meaning for different Handlers. Warning Please exercise caution when changing the values of the parameters in this group: a wrong choice can severely impact data retrieval and result in OM not working correctly.","title":"data_retrieval_layer"},{"location":"parameters/#all-data-event-handlers","text":"The parameters in this subsection apply to all Data Event Handlers required_data (List[str]) The data that the current monitor should retrieve for each event. For each type of data listed here, an extraction function must be available for the Data Event Handler that OM is currently using. If this condition is met, the data will be retrieved and made available for processing, otherwise an error will be raised an OM will stop running. For a list of all data types that each Data Event Handler can currently retrieve, please see the following document: List of data types available for each Data Event Handler Example: [detector_data, detector_distance, beam_energy, timestamp]","title":"All Data Event Handlers"},{"location":"parameters/#psana-based-data-event-handlers","text":"The parameters in this section apply only to the psana-based Data Event Handlers, specifically: CxiLclsDataEventHandler CxiLclsCspadDataEventHandler MfxLclsDataEventHandler MfxLclsRayonixDataEventHandler active_optical_laser_evr_code (int) EVR event code corresponding to an active optical laser. To determine if the optical laser is active, OM checks if the code provided by this parameter matches one of the EVR event codes associated with the current event. Example: 92 active_xray_evr_code (int) EVR event code corresponding to the x-rays being active. To determine if the x-rays are active, OM checks if the code provided by this parameter matches one of the EVR event codes associated with the current event. Example: 42 calibration (bool) Whether to retrieve calibrated or non calibrated x-ray detector data from psana. This parameter switches on and off the internal calibration provided by psana. Example: true psana_calibration_directory (str) The path to the directory where psana stores all calibration information for the current experiment. Example: /reg/d/psdm/mfx/mfxc00118/calib psana_detector_name (str) The name of the main x-ray detector from which psana retrieves data. Example: DscCsPad psana_detector_distance_epics_name (str) The name of the Epics variable from which psana retrieves detector distance information for the main x-ray detector. Example: CXI:DS1:MMS:06.RBV psana_digitizer_name (str) The name of the main digitizer device from which psana retrieves information. Example: Acqiris psana_evr_source_name (str) The name of the EVR source from which psana retrieves information. Example: evr0 psana_opal_name (str) The name of the Opal camera from which psana retrieves information. Example: Opal1 psana_timetool_epics_name (str) The name of the Epics variable from which psana retrieves timetool information. Example: CXI:DS1:MMS:06.RBV","title":"Psana-based Data Event Handlers"},{"location":"parameters/#filesystem-based-data-event-handlers","text":"The parameters in this section apply only to the file-based Data Event Handlers, and specifically to the following Handlers: PilatusFilesDataEventHandler JungFrau1MDataEventHandler calibration(bool) Whether to calibrate the retrieved x-ray detector data or not. When reading from files, the calibration of the detector data is usually performed by OM. OM often needs external information to perform the calibration, and retrieves it from a set of files defined by the calibration_dark_filenames and calibration_gain_filenames parameters. In some cases, additional parameters (for example calibration_photon_energy_kev ) must also be provided to further define the calibration process. Example: true calibration_dark_filenames (Union[str, List[str]]) File or list of files containing dark frame information for the calibration of x-ray detector data. If dark frame information is needed by the detector being calibrated, OM will read the information from the files specified by this parameter. If, however, the calibration is not performed or if the Data Event Handler does not need dark frame information for the calibration, this parameter is ignored. Example: dark_info.h5 or [dark_info_panel0.h5, dark_info_panel1.h5] calibration_gain_filenames (Union[str, List[str]]) File or list of files containing gain information for the calibration of x-ray detector data. If gain information is needed by the detector being calibrated, OM will read the information from the files specified by this parameter. If, however, the calibration is not performed or if the Data Event Handler does not need gain information for the calibration, this parameter is ignored. Example: gain_info.h5 or [gain_info_panel0.h5, gain_info_panel1.h5] calibration_photon_energy_kev (float) The photon energy for which the x-ray detector data should be calibrated. The exact values of the calibration constants for a detector often depend on the photon energy at which the detector is operated. If a calibration algorithm needs this information, OM will take the value provided by this parameter. If, however, the calibration is not performed or if the Data Event Handler does not need this kind of information for the calibration, this parameter is ignored. Example: 9.1 fallback_beam_energy_in_eV (float) The beam energy in eV . OM uses this fallback value when the the relevant information is not present in the data files. Example: 12000 fallback_detector_distance_in_mm (float) The detector distance in mm . OM uses this fallback value when the the relevant information is not present in the data files. Example: 250 num_frames_in_event_to_process (int) The number of frames in an event that OM should process. Sometimes data events contain multiple frames but OM does not need to process them all. This parameter specifies how many frames OM should consider. Please note that OM will give precedence to the frames in the event that were collected more recently. If, for example, this parameter specifies that OM should process n frames, OM will process the last n frames in the event. Example: 1","title":"Filesystem-based Data Event Handlers"},{"location":"parameters/#om","text":"Warning This section determines the core behavior of the OM monitor. The value of these parameters should be changed only by an expert. A wrong parameter choice is likely to leave OM in a non-working state. data_event_handler (str) The name of the class implementing the Data Event Handler currently used by OM. The class should be defined in the Data Retrieval Layer module file specified by the data_retrieval_layer parameter in this group. Example: MfxLclsDataEventHandler data_retrieval_layer (str) The name of the python module with the implementation of the Data Retrieval Layer currently used by OM. Example: data_handlers_psana monitor (str) The name of the class implementing the Monitor currently used by OM. The class should be defined in the Processing Layer module file specified by the processing_layer parameter in this group. Example: Crystallography parallelization_engine (str) The name of the class implementing the Parallelization Engine currently used by OM. The class should be defined in the Parallelization Layer module file specified by the parallelization_layer parameter in this group. Example: MpiParallelizationEngine parallelization_layer (str) The name of the python module with the implementation of the Parallelization Layer currently used by OM. Example: mpi processing_layer (str) The name of the python module with the implementation of the Processing Layer currently used by OM. Example: crystallography","title":"om"},{"location":"parameters/#peakfinder8_peak_detection","text":"This parameter group contains parameters that control how OM performs peak finding on a detector data frame using the Peakfinder8PeakDetection algorithm. adc_threshold (float) The minimum ADC threshold for peak detection. Example: 200 bad_pixel_map_filename (str or None) The absolute or relative path to an HDF5 file containing a bad pixel map. The map is used to mark areas of the data frame that must be excluded from the peak search. Each pixel in the map must have a value of either 0, meaning that the corresponding pixel in the data frame must be ignored, or 1, meaning that the corresponding pixel must be included in the search. The map is only used to exclude areas from the peak search: the data is not modified in any way. If the value of these parameter is None , no area is excluded from the peak search. Example: bad_pixel_mask.h5 bad_pixel_map_hdf5_path (str or None) The internal HDF5 path to the data block where the bad pixel map is stored. If the value of the bad_pixel_map_filename parameter is not None , this parameter must also be provided, and cannot be None . Otherwise it is ignored. Example: /data/data detector_type (str) The type of detector on which the peak finding algorithm will be applied. The detector types currently supported are: cspad pilatus jungfrau1M jungfrau4M epix10k2M Rayonix Example: cspad max_num_peaks (int) The maximum number of peaks that will be retrieved from each detector data frame. Additional peaks will be ignored. Example: 2048 local_bg_radius (int) The radius (in pixels) for the estimation of the local background. Example: 3 max_pixel_count (int) The maximum size of a peak in pixels. Example: 10 max_res (int) The maximum resolution (in pixels) at which a peak will be found. Example: 800 min_pixel_count (int) The minimum size of a peak in pixels. Example: 1 minimum_snr (float) The minimum signal-to-noise ratio for peak detection. Example: 5.0 min_res (int): The minimum resolution for a peak in pixels. Example: 20","title":"peakfinder8_peak_detection"},{"location":"running_om/","text":"Running OM Running OM at the LCLS Facility (MFX and CXI Beamlines) The run_om.sh File At the MFX and CXI beamlines of the LCLS facility, OM must be run on a specific set of machines known as monitoring nodes . Only on these machines the data stream can be accessed in real time. The monitoring nodes have hostnames that match the following scheme: Monitoring nodes at the CXI beamline: daq-cxi-mon<XX> Monitoring nodes at the MFX beamline: daq-mfx-mon<XX> In these hostnames, <XX> is a zero-padded integer number. The specific monitoring nodes that should be used to run OM can change for each experiment and sometimes even within the same experiment. The beamline scientists can usually provide information about the nodes that should be used at any given time. Once access to the monitoring nodes has been obtained, a file called run_om.sh should be created with the following content: # In the last lines, replace X with the number of OM nodes # to run on each machine and Y with a comma-separated list # of hostnames for machines on which OM should be launched. source /cds/sw/ds/ana/conda1/manage/bin/psconda.sh -py3 echo Creating and Running $( pwd ) /monitor_wrapper.sh echo '#!/bin/bash' > $( pwd ) /monitor_wrapper.sh echo '# File automatically created by the' >> $( pwd ) /monitor_wrapper.sh echo '# run_om.sh script, please do not' >> $( pwd ) /monitor_wrapper.sh echo '# edit directly.' >> $( pwd ) /monitor_wrapper.sh echo 'source <OM> >> $(pwd)/monitor_wrapper.sh echo \"om_monitor.py ' shmem = psana.0:stop = no ' \" >> $( pwd ) /monitor_wrapper.sh chmod +x $( pwd ) /monitor_wrapper.sh $( which mpirun ) --oversubscribe --map-by ppr:X:node \\ --host Y $( pwd ) /monitor_wrapper.sh In the last two lines, X must be replaced with the number of processes that OM should start on each monitoring node, and Y with a comma-separated list of hostnames or IP addresses of machines on which OM should be launched (This information is usually provided by the beamline scientists). Examples of run_om.sh files for the MFX and CXI beamlines can be found at the following links: Example run_om.sh script for the MFX beamline Example run_om.sh script for the CXI beamline Warning Please note that these files aree just examples . They might need to be modified before being used for specific experiments. The monitor.yaml File In the same folder as the previous script, a monitor.yaml configuration file should be created. (See this section for a full discussion of the format and content of the configuration file). Example configuration files for the MFX and CXI beamlines can be found at the following links: Example monitor.yaml file for the MFX beamline Example monitor.yaml file for the CXI beamline Warning Please note that these files are just examples . They might need to be modified before being used for specific experiments. This is particularly true for the entries in the file that define the calibration directory and the detector name , and for the ones that define the epics variables associated with beam energy and detector distance. These are usually all experiment-dependent. The Geometry File In most cases, the monitor.yaml file will instruct OM to look for a CrystFEL geometry file for the x-ray detector used at the beamline. Example geometry files for several x-ray detectors can be found at the following link: Example geometry files for x-ray detectors In their default setup, the MFX and CXI beamlines use the Epix10ka and Jungfrau1M detectors. Example geometry files for these detectors can be found here: Example Epix10ka@M geometry file for the MFX beamline Example Jungfrau4M geometry file for the CXI beamline Warning Please note that these files are just examples . They might need to be modified before being used for specific experiments. Running OM Once everything is setup, OM can be launched by simply running the run_om.sh script from a terminal. Please note that the script should be launched from a monitoring node machine, or from a computer that has a direct connection to all the monitoring nodes. At the MFX beamline, for example, mfx-daq and mfx-monitor are suitable hosts, as are cxi-daq and cxi-monitor at the CXI beamline. After OM has been started, please see this paragraph on how to run OM's graphical interfaces. Running OM on a Laptop/Desktop Introduction When OM is launched on an a standalone computer, it is often very hard or impossible to connect to a facility's framework to retrieve data. Therefore, in the following example, OM will process data coming from files stored on disk, rather than real-time data from a facility. Specifically, this example will deal with files written by a Pilatus x-ray detector in CBF format. These files have been chosen because they are relatively small in size and easy to copy from one machine to the other. This setup, where OM processes data coming from files rather than from a facility's framework, is a very good solution for testing and debugging purposes. Note Although it is possible to run OM on a small standalone computer, it should be noted that OM is not designed or optimized for the limited resources of a laptop or a small desktop computer. The Data Files This example uses data files from an experiment performed by Ti-Yen Lan's research group at the APS facility, part of the Argonne National Laboratory in the USA. These files have been deposited in the Coherent X-ray Imaging Data Bank , an online database of data from Serial Crystallography experiments. The following paragraphs assume that the file data8.tar.gz has been downloaded from here and unpacked in a folder on the local computer. Warning Beware of storage space limitation and long download times: the data, even compressed, has a size 24Gb ! The monitor.yaml file In oder to run OM, a monitor.yaml configuration file should be created on the local computer (See this section for a full discussion of the format and content of the configuration file). The following file can be used for the dataset in this example: Example monitor.yaml file for Ti-Yen Lan's dataset Warning This configuration file has been adapted to the dataset in this example. Please note that a completely different configuration file might be needed for other datasets. Please consult the documentation linked above for a detailed explanation of each entry in the file. Also note that all the files mentioned in the configuration file (geometry file, masks, etc.) must be present and readable on the local computer for OM to work properly. The Geometry File The monitor.yaml file linked above instructs OM to load a CrystFEL geometry file for the x-ray detector used during the experiment. Examples geometry files for several detectors used at various facilities and beamlines can be found at the following link: Example geometry files for x-ray detectors However, for the current example, just a Pilatus detector geometry file is needed: Example Pilatus geometry file Warning Please note that this files is just an example . It works well for this example but might need to be modified to process data from another experiment, even if the same detector was used. Running OM In order to have OM work on data from files, it is necessary to let the program know which files should be processed, and where to find them on the local computer. A list of files that OM must process needs to be generated. Each file must be listed on a separate line, each with its own full absolute or relative path. The list must then be saved into yet another file. For this example, the list file can easily be created using the UNIX find command: find <PATH TO DATA> -name \"*cbf\" > files.lst In this command, <PATH TO DATA> should point to the folder where the previously downloaded data file has been unpacked. Assuming that the files are in the data8 subdirectory of the current working folder, for example, the files.lst file should read: data8/lysozyme2_test_000437.cbf data8/lysozyme2_test_005699.cbf data8/lysozyme2_test_001000.cbf data8/lysozyme2_test_006581.cbf data8/lysozyme2_test_006410.cbf ... OM can finally be started from the folder where the monitor.toml , pilatus.geom and files.lst files are located, using the following command: mpirun -n <NUM NODES> om_monitor.py files.lst In this command, <NUM NODES> must be replaced with the total number of nodes that OM should use (several processing nodes and a collecting node). For a standalone computer, and for testing purposes, a value of 3 (just 2 processing + 1 collecting nodes) is recommended. After OM has been started, please see this paragraph on how to run OM's graphical interfaces. Running OM's Graphical Interfaces Broadcasting URL As the monitor starts, it prints on the console a line that contains the following string: Broadcasting data at <URL> In this message, <URL> is a string of the form protocol://location , and it describes the protocol used by OM to broadcast the data (TCP or IPC), in addition to the location where the data is being broadcast. With the TCP protocol, the location is usually an IP address plus a port separated by a colon ( XXX.XXX.XXX.XXX:port ). When the IPC protocol is used, the location is usually the absolute path to a filesystem socket ( /path/to/socket ). Launching the Graphical Interfaces The broadcasting protocol and location are the only pieces of information needed to launch most of OM's graphical interfaces. The GUIs can be started using a command with the following format: <GUI COMMAND> <URL> Where <GUI COMMAND> is the name of the GUI script, and <URL> is the string printed out by OM at start up. For example, the Crystallography GUI and the Crystallography Frame Viewer, could be launched with the following commands: TCP Protocol om_crystallography_gui.py tcp://127.0.0.1:12321 IPC Protocol om_crystallography_gui.py ipc://mfxopr/om_socket and TCP Protocol om_crystallography_frame_viewer.py tcp://127.0.0.1:12321 IPC Protocol om_crystallography_frame_viewer.py ipc://mfxopr/om_socket In general OM's graphical interfaces do not need to be launched on the same computer where OM is running. However, the location where the data is broadcast should be visible and reachable from the computer where the GUIs are running. Furthermore, some specific graphical interfaces might need access to files or information that is only present on the machine where OM is running. For example, OM's Crystallography Parameter Tweaker needs to access the monitor.yaml file, so it must either be run from the same computer and folder as OM, or the file must be copied over to the machine where the GUI is running. Error Messages When something does not work as expected, OM emits error messages. Errors can be fatal, in which case the monitor stops, or not, in which case OM just reports the error and continues processing data. OM errors are not reported as normal Python errors. They are clearly labelled as coming from the monitor, and their traceback information is removed. The --debug option to the om_monitor.py script disables this behavior and forces OM to report all errors as normal Python errors. When the OM's Parallelization Engine is used, OM fatal errors are often reported multiple times before the monitor finishes operating: it can happen that multiple nodes report the same error independently before the MPI engine can stop. A brief description of the most common error messages, and the measures needed to mitigate them, can be found at the following link: Most common error messages from OM","title":"Running OM"},{"location":"running_om/#running-om","text":"","title":"Running OM"},{"location":"running_om/#running-om-at-the-lcls-facility-mfx-and-cxi-beamlines","text":"","title":"Running OM at the LCLS Facility (MFX and CXI Beamlines)"},{"location":"running_om/#the-run_omsh-file","text":"At the MFX and CXI beamlines of the LCLS facility, OM must be run on a specific set of machines known as monitoring nodes . Only on these machines the data stream can be accessed in real time. The monitoring nodes have hostnames that match the following scheme: Monitoring nodes at the CXI beamline: daq-cxi-mon<XX> Monitoring nodes at the MFX beamline: daq-mfx-mon<XX> In these hostnames, <XX> is a zero-padded integer number. The specific monitoring nodes that should be used to run OM can change for each experiment and sometimes even within the same experiment. The beamline scientists can usually provide information about the nodes that should be used at any given time. Once access to the monitoring nodes has been obtained, a file called run_om.sh should be created with the following content: # In the last lines, replace X with the number of OM nodes # to run on each machine and Y with a comma-separated list # of hostnames for machines on which OM should be launched. source /cds/sw/ds/ana/conda1/manage/bin/psconda.sh -py3 echo Creating and Running $( pwd ) /monitor_wrapper.sh echo '#!/bin/bash' > $( pwd ) /monitor_wrapper.sh echo '# File automatically created by the' >> $( pwd ) /monitor_wrapper.sh echo '# run_om.sh script, please do not' >> $( pwd ) /monitor_wrapper.sh echo '# edit directly.' >> $( pwd ) /monitor_wrapper.sh echo 'source <OM> >> $(pwd)/monitor_wrapper.sh echo \"om_monitor.py ' shmem = psana.0:stop = no ' \" >> $( pwd ) /monitor_wrapper.sh chmod +x $( pwd ) /monitor_wrapper.sh $( which mpirun ) --oversubscribe --map-by ppr:X:node \\ --host Y $( pwd ) /monitor_wrapper.sh In the last two lines, X must be replaced with the number of processes that OM should start on each monitoring node, and Y with a comma-separated list of hostnames or IP addresses of machines on which OM should be launched (This information is usually provided by the beamline scientists). Examples of run_om.sh files for the MFX and CXI beamlines can be found at the following links: Example run_om.sh script for the MFX beamline Example run_om.sh script for the CXI beamline Warning Please note that these files aree just examples . They might need to be modified before being used for specific experiments.","title":"The run_om.sh File"},{"location":"running_om/#the-monitoryaml-file","text":"In the same folder as the previous script, a monitor.yaml configuration file should be created. (See this section for a full discussion of the format and content of the configuration file). Example configuration files for the MFX and CXI beamlines can be found at the following links: Example monitor.yaml file for the MFX beamline Example monitor.yaml file for the CXI beamline Warning Please note that these files are just examples . They might need to be modified before being used for specific experiments. This is particularly true for the entries in the file that define the calibration directory and the detector name , and for the ones that define the epics variables associated with beam energy and detector distance. These are usually all experiment-dependent.","title":"The monitor.yaml File"},{"location":"running_om/#the-geometry-file","text":"In most cases, the monitor.yaml file will instruct OM to look for a CrystFEL geometry file for the x-ray detector used at the beamline. Example geometry files for several x-ray detectors can be found at the following link: Example geometry files for x-ray detectors In their default setup, the MFX and CXI beamlines use the Epix10ka and Jungfrau1M detectors. Example geometry files for these detectors can be found here: Example Epix10ka@M geometry file for the MFX beamline Example Jungfrau4M geometry file for the CXI beamline Warning Please note that these files are just examples . They might need to be modified before being used for specific experiments.","title":"The Geometry File"},{"location":"running_om/#running-om_1","text":"Once everything is setup, OM can be launched by simply running the run_om.sh script from a terminal. Please note that the script should be launched from a monitoring node machine, or from a computer that has a direct connection to all the monitoring nodes. At the MFX beamline, for example, mfx-daq and mfx-monitor are suitable hosts, as are cxi-daq and cxi-monitor at the CXI beamline. After OM has been started, please see this paragraph on how to run OM's graphical interfaces.","title":"Running OM"},{"location":"running_om/#running-om-on-a-laptopdesktop","text":"","title":"Running OM on a Laptop/Desktop"},{"location":"running_om/#introduction","text":"When OM is launched on an a standalone computer, it is often very hard or impossible to connect to a facility's framework to retrieve data. Therefore, in the following example, OM will process data coming from files stored on disk, rather than real-time data from a facility. Specifically, this example will deal with files written by a Pilatus x-ray detector in CBF format. These files have been chosen because they are relatively small in size and easy to copy from one machine to the other. This setup, where OM processes data coming from files rather than from a facility's framework, is a very good solution for testing and debugging purposes. Note Although it is possible to run OM on a small standalone computer, it should be noted that OM is not designed or optimized for the limited resources of a laptop or a small desktop computer.","title":"Introduction"},{"location":"running_om/#the-data-files","text":"This example uses data files from an experiment performed by Ti-Yen Lan's research group at the APS facility, part of the Argonne National Laboratory in the USA. These files have been deposited in the Coherent X-ray Imaging Data Bank , an online database of data from Serial Crystallography experiments. The following paragraphs assume that the file data8.tar.gz has been downloaded from here and unpacked in a folder on the local computer. Warning Beware of storage space limitation and long download times: the data, even compressed, has a size 24Gb !","title":"The Data Files"},{"location":"running_om/#the-monitoryaml-file_1","text":"In oder to run OM, a monitor.yaml configuration file should be created on the local computer (See this section for a full discussion of the format and content of the configuration file). The following file can be used for the dataset in this example: Example monitor.yaml file for Ti-Yen Lan's dataset Warning This configuration file has been adapted to the dataset in this example. Please note that a completely different configuration file might be needed for other datasets. Please consult the documentation linked above for a detailed explanation of each entry in the file. Also note that all the files mentioned in the configuration file (geometry file, masks, etc.) must be present and readable on the local computer for OM to work properly.","title":"The monitor.yaml file"},{"location":"running_om/#the-geometry-file_1","text":"The monitor.yaml file linked above instructs OM to load a CrystFEL geometry file for the x-ray detector used during the experiment. Examples geometry files for several detectors used at various facilities and beamlines can be found at the following link: Example geometry files for x-ray detectors However, for the current example, just a Pilatus detector geometry file is needed: Example Pilatus geometry file Warning Please note that this files is just an example . It works well for this example but might need to be modified to process data from another experiment, even if the same detector was used.","title":"The Geometry File"},{"location":"running_om/#running-om_2","text":"In order to have OM work on data from files, it is necessary to let the program know which files should be processed, and where to find them on the local computer. A list of files that OM must process needs to be generated. Each file must be listed on a separate line, each with its own full absolute or relative path. The list must then be saved into yet another file. For this example, the list file can easily be created using the UNIX find command: find <PATH TO DATA> -name \"*cbf\" > files.lst In this command, <PATH TO DATA> should point to the folder where the previously downloaded data file has been unpacked. Assuming that the files are in the data8 subdirectory of the current working folder, for example, the files.lst file should read: data8/lysozyme2_test_000437.cbf data8/lysozyme2_test_005699.cbf data8/lysozyme2_test_001000.cbf data8/lysozyme2_test_006581.cbf data8/lysozyme2_test_006410.cbf ... OM can finally be started from the folder where the monitor.toml , pilatus.geom and files.lst files are located, using the following command: mpirun -n <NUM NODES> om_monitor.py files.lst In this command, <NUM NODES> must be replaced with the total number of nodes that OM should use (several processing nodes and a collecting node). For a standalone computer, and for testing purposes, a value of 3 (just 2 processing + 1 collecting nodes) is recommended. After OM has been started, please see this paragraph on how to run OM's graphical interfaces.","title":"Running OM"},{"location":"running_om/#running-oms-graphical-interfaces","text":"","title":"Running OM's Graphical Interfaces"},{"location":"running_om/#broadcasting-url","text":"As the monitor starts, it prints on the console a line that contains the following string: Broadcasting data at <URL> In this message, <URL> is a string of the form protocol://location , and it describes the protocol used by OM to broadcast the data (TCP or IPC), in addition to the location where the data is being broadcast. With the TCP protocol, the location is usually an IP address plus a port separated by a colon ( XXX.XXX.XXX.XXX:port ). When the IPC protocol is used, the location is usually the absolute path to a filesystem socket ( /path/to/socket ).","title":"Broadcasting URL"},{"location":"running_om/#launching-the-graphical-interfaces","text":"The broadcasting protocol and location are the only pieces of information needed to launch most of OM's graphical interfaces. The GUIs can be started using a command with the following format: <GUI COMMAND> <URL> Where <GUI COMMAND> is the name of the GUI script, and <URL> is the string printed out by OM at start up. For example, the Crystallography GUI and the Crystallography Frame Viewer, could be launched with the following commands: TCP Protocol om_crystallography_gui.py tcp://127.0.0.1:12321 IPC Protocol om_crystallography_gui.py ipc://mfxopr/om_socket and TCP Protocol om_crystallography_frame_viewer.py tcp://127.0.0.1:12321 IPC Protocol om_crystallography_frame_viewer.py ipc://mfxopr/om_socket In general OM's graphical interfaces do not need to be launched on the same computer where OM is running. However, the location where the data is broadcast should be visible and reachable from the computer where the GUIs are running. Furthermore, some specific graphical interfaces might need access to files or information that is only present on the machine where OM is running. For example, OM's Crystallography Parameter Tweaker needs to access the monitor.yaml file, so it must either be run from the same computer and folder as OM, or the file must be copied over to the machine where the GUI is running.","title":"Launching the Graphical Interfaces"},{"location":"running_om/#error-messages","text":"When something does not work as expected, OM emits error messages. Errors can be fatal, in which case the monitor stops, or not, in which case OM just reports the error and continues processing data. OM errors are not reported as normal Python errors. They are clearly labelled as coming from the monitor, and their traceback information is removed. The --debug option to the om_monitor.py script disables this behavior and forces OM to report all errors as normal Python errors. When the OM's Parallelization Engine is used, OM fatal errors are often reported multiple times before the monitor finishes operating: it can happen that multiple nodes report the same error independently before the MPI engine can stop. A brief description of the most common error messages, and the measures needed to mitigate them, can be found at the following link: Most common error messages from OM","title":"Error Messages"},{"location":"the_om_development_team/","text":"The OM Development Team Active Developers OM is currently developed at the Linac Coherent Light Source facility (LCLS) of the SLAC National Accelerator Laboratory. However, several collaborators from different institutions all over the world contribute code, testing and support to the project. The current core development team includes the following people: Valerio Mariani (corresponding developer: valmar@slac.stanford.edu ) Anton Barty Thomas Grant Alexandra Tolstikova Contributors Several people have, over the years, contributed to the development and testing of OM with code, bug reports, ideas, etc. Some still do, occasionally. The following list might not be exhaustive: Steve Aplin Henry Chapman Jason Koglin Manuela Kuhn Luca Gelisio Mia Lahey-Rudolph Thomas J. Lane Andrew Morgan Christopher O'Grady Kanupriya Pande Thomas A. White Chun Hong Yoon Guidelines for Contributions New contributors to OM are always welcome! This section contains some guidelines about coding style, language versions, etc. Please follow these guidelines whenever possible when contributing to the development of OM. Version Control OM is developed using the Git version control system. OM's versioning scheme follows the Calendar Versioning system. Specifically, OM's version number uses the following format: YY.MM.MINOR.[MICRO] OM's development takes place on GitHub , and follows the GitHub workflow . Bugs, issues, ideas for improvement, etc should be reported on the issue tracker of OM's main repository Python OM is mainly developed using the Python programming language. All of OM's code should run with with all actively supported versions of Python (currently 3.6 to 3.9), with the only exception of facility-related code that requires a specific version of Python to run. The Google Python Style Guide should be followed for all matters related to coding style and coding conventions. All docstrings should be written according to the Google Style . Before code is submitted to the main repository, the following linters and formatters should be run on it: Flake8 : in the root folder of the OM repository, the setup.cfg file stores the settings that should be applied when linting OM\u2019s code with Flake8. Black : the default options should be used. C/C++ Some OM extensions and plugins can, for performance reason, be written using the C++ or C programming languages. All the C++ code in OM should follow at most the C++98 ISO standard, and the code should compile on a Linux RHEL7/CentOS7 platform using the development stack that comes with a standard installation of the system. Part of the C++11 standard can be used when writing extensions. However, it must be possible to compile the code using version 4.8 of the gcc compiler (This requirement and the previous one are imposed by the OS version that must be used to create official Linux Python wheels). All the C code in OM should follow at most the C99 ISO standard, and the code should compile on a Linux RHEL7/CentOS7 platform using the development stack that comes with a standard installation of the system (This requirement also comes from the OS version used to create the official Linux Python wheels). The Cython framework should be used to interface C/C++ code with Python.","title":"The OM Development Team"},{"location":"the_om_development_team/#the-om-development-team","text":"","title":"The OM Development Team"},{"location":"the_om_development_team/#active-developers","text":"OM is currently developed at the Linac Coherent Light Source facility (LCLS) of the SLAC National Accelerator Laboratory. However, several collaborators from different institutions all over the world contribute code, testing and support to the project. The current core development team includes the following people: Valerio Mariani (corresponding developer: valmar@slac.stanford.edu ) Anton Barty Thomas Grant Alexandra Tolstikova","title":"Active Developers"},{"location":"the_om_development_team/#contributors","text":"Several people have, over the years, contributed to the development and testing of OM with code, bug reports, ideas, etc. Some still do, occasionally. The following list might not be exhaustive: Steve Aplin Henry Chapman Jason Koglin Manuela Kuhn Luca Gelisio Mia Lahey-Rudolph Thomas J. Lane Andrew Morgan Christopher O'Grady Kanupriya Pande Thomas A. White Chun Hong Yoon","title":"Contributors"},{"location":"the_om_development_team/#guidelines-for-contributions","text":"New contributors to OM are always welcome! This section contains some guidelines about coding style, language versions, etc. Please follow these guidelines whenever possible when contributing to the development of OM.","title":"Guidelines for Contributions"},{"location":"the_om_development_team/#version-control","text":"OM is developed using the Git version control system. OM's versioning scheme follows the Calendar Versioning system. Specifically, OM's version number uses the following format: YY.MM.MINOR.[MICRO] OM's development takes place on GitHub , and follows the GitHub workflow . Bugs, issues, ideas for improvement, etc should be reported on the issue tracker of OM's main repository","title":"Version Control"},{"location":"the_om_development_team/#python","text":"OM is mainly developed using the Python programming language. All of OM's code should run with with all actively supported versions of Python (currently 3.6 to 3.9), with the only exception of facility-related code that requires a specific version of Python to run. The Google Python Style Guide should be followed for all matters related to coding style and coding conventions. All docstrings should be written according to the Google Style . Before code is submitted to the main repository, the following linters and formatters should be run on it: Flake8 : in the root folder of the OM repository, the setup.cfg file stores the settings that should be applied when linting OM\u2019s code with Flake8. Black : the default options should be used.","title":"Python"},{"location":"the_om_development_team/#cc","text":"Some OM extensions and plugins can, for performance reason, be written using the C++ or C programming languages. All the C++ code in OM should follow at most the C++98 ISO standard, and the code should compile on a Linux RHEL7/CentOS7 platform using the development stack that comes with a standard installation of the system. Part of the C++11 standard can be used when writing extensions. However, it must be possible to compile the code using version 4.8 of the gcc compiler (This requirement and the previous one are imposed by the OS version that must be used to create official Linux Python wheels). All the C code in OM should follow at most the C99 ISO standard, and the code should compile on a Linux RHEL7/CentOS7 platform using the development stack that comes with a standard installation of the system (This requirement also comes from the OS version used to create the official Linux Python wheels). The Cython framework should be used to interface C/C++ code with Python.","title":"C/C++"},{"location":"reference/om/","text":"om special OM: OnDA Monitor. This is the main OnDA Monitor package. It contains the full implementation of the OM framework, which is subdivided into several different subpackages. algorithms data_retrieval_layer graphical_interfaces lib monitor parallelization_layer processing_layer utils","title":"__init__"},{"location":"reference/om/#om","text":"OM: OnDA Monitor. This is the main OnDA Monitor package. It contains the full implementation of the OM framework, which is subdivided into several different subpackages. algorithms data_retrieval_layer graphical_interfaces lib monitor parallelization_layer processing_layer utils","title":"om"},{"location":"reference/om/monitor/","text":"monitor OM's main function. This module contains the main function that instantiates an OnDA Monitor when called. om_monitor.py OnDA Monitor. This script starts a online data analysis monitor that behaves according to the parameters defined in the provided configuration file. The monitor retrieves data from the source specified by SOURCE_STRING. The exact format of SOURCE_STRING depends on the specific Data Extraction Layer currently used by the monitor (see the relevant documentation). When the 'mpi' Parallelization Layer is used, this script should be launched via the 'mpirun' or 'mpiexec' commands. Usage: om_monitor.py [OPTIONS] SOURCE Options: -c, --config PATH The path to a configuration file (default: monitor.yaml file in the current working directory) -d, --debug Disable the custom OM error handler for OM-related exceptions. Useful for debugging. --help Show this message and exit.","title":"monitor"},{"location":"reference/om/monitor/#om.monitor","text":"OM's main function. This module contains the main function that instantiates an OnDA Monitor when called.","title":"monitor"},{"location":"reference/om/monitor/#om_monitorpy","text":"OnDA Monitor. This script starts a online data analysis monitor that behaves according to the parameters defined in the provided configuration file. The monitor retrieves data from the source specified by SOURCE_STRING. The exact format of SOURCE_STRING depends on the specific Data Extraction Layer currently used by the monitor (see the relevant documentation). When the 'mpi' Parallelization Layer is used, this script should be launched via the 'mpirun' or 'mpiexec' commands. Usage: om_monitor.py [OPTIONS] SOURCE Options: -c, --config PATH The path to a configuration file (default: monitor.yaml file in the current working directory) -d, --debug Disable the custom OM error handler for OM-related exceptions. Useful for debugging. --help Show this message and exit.","title":"om_monitor.py"},{"location":"reference/om/algorithms/","text":"algorithms special OM's Algorithms. This package contains OM's Algorithms: classes that implement calculations and other operations on the data. The available algorithms are grouped into several categories, each corresponding to a separate module. calibration crystallography generic","title":"__init__"},{"location":"reference/om/algorithms/#om.algorithms","text":"OM's Algorithms. This package contains OM's Algorithms: classes that implement calculations and other operations on the data. The available algorithms are grouped into several categories, each corresponding to a separate module. calibration crystallography generic","title":"algorithms"},{"location":"reference/om/algorithms/calibration/","text":"calibration Algorithms for detector calibration. This module contains algorithms that can be used to calibrate raw detector data. Each algorithm deals with a specific detector. Jungfrau1MCalibration See documentation of the __init__ function. __init__ ( self , dark_filenames , gain_filenames , photon_energy_kev ) special Calibration of the Jungfrau 1M detector. This algorithm stores the calibration parameters for a Jungfrau 1M detector and applies them to a raw detector data frame upon request. Parameters: Name Type Description Default dark_filenames List[str] A list of relative or absolute paths to files containing dark data for the calibration of the detector. required gain_filenames List[str] A list of relative or absolute paths to files containing gain data for the calibration of the detector. required photon_energy_kev float the photon energy at which the detector will be operated. required apply_calibration ( self , data ) Applies the calibration to a detector data frame. This function determines the gain stage of each pixel in the provided data frame, and applies the relevant gain and offset corrections. Parameters: Name Type Description Default data ndarray The detector data frame to calibrate. required Returns: Type Description ndarray The corrected data frame.","title":"calibration"},{"location":"reference/om/algorithms/calibration/#om.algorithms.calibration","text":"Algorithms for detector calibration. This module contains algorithms that can be used to calibrate raw detector data. Each algorithm deals with a specific detector.","title":"calibration"},{"location":"reference/om/algorithms/calibration/#om.algorithms.calibration.Jungfrau1MCalibration","text":"See documentation of the __init__ function.","title":"Jungfrau1MCalibration"},{"location":"reference/om/algorithms/calibration/#om.algorithms.calibration.Jungfrau1MCalibration.__init__","text":"Calibration of the Jungfrau 1M detector. This algorithm stores the calibration parameters for a Jungfrau 1M detector and applies them to a raw detector data frame upon request. Parameters: Name Type Description Default dark_filenames List[str] A list of relative or absolute paths to files containing dark data for the calibration of the detector. required gain_filenames List[str] A list of relative or absolute paths to files containing gain data for the calibration of the detector. required photon_energy_kev float the photon energy at which the detector will be operated. required","title":"__init__()"},{"location":"reference/om/algorithms/calibration/#om.algorithms.calibration.Jungfrau1MCalibration.apply_calibration","text":"Applies the calibration to a detector data frame. This function determines the gain stage of each pixel in the provided data frame, and applies the relevant gain and offset corrections. Parameters: Name Type Description Default data ndarray The detector data frame to calibrate. required Returns: Type Description ndarray The corrected data frame.","title":"apply_calibration()"},{"location":"reference/om/algorithms/crystallography/","text":"crystallography Algorithms for the processing of crystallography data. This module contains algorithms that perform crystallography-related data processing (peak finding, etc.). In addition, it also contains several typed dictionaries that store data needed or produced by these algorithms. Peakfinder8PeakDetection See documentation of the __init__ function. __init__ ( self , max_num_peaks , asic_nx , asic_ny , nasics_x , nasics_y , adc_threshold , minimum_snr , min_pixel_count , max_pixel_count , local_bg_radius , min_res , max_res , bad_pixel_map , radius_pixel_map ) special Peakfinder8 algorithm for peak detection. This algorithm stores the parameters required to find peaks in a detector data frame using the 'peakfinder8' strategy, and performs peak finding on a data frame upon request. The 'peakfinder8' peak detection strategy is described in the following publication: A. Barty, R. A. Kirian, F. R. N. C. Maia, M. Hantke, C. H. Yoon, T. A. White, and H. N. Chapman, \"Cheetah: software for high-throughput reduction and analysis of serial femtosecond x-ray diffraction data\", J Appl Crystallogr, vol. 47, pp. 1118-1131 (2014). Parameters: Name Type Description Default max_num_peaks int The maximum number of peaks that will be retrieved from each data frame. Additional peaks will be ignored. required asic_nx int The fs size in pixels of each detector panel in the data frame (Can be retrieved from a TypePeakfinder8Info dictionary). required asic_ny int The ss size in pixels of each detector panel in the data frame (Can be retrieved from a TypePeakfinder8Info dictionary). required nasics_x int The number of panels along the fs axis of the data frame (Can be retrieved from a TypePeakfinder8Info dictionary). required nasics_y int The number of panels along the ss axis of the data frame (Can be retrieved from a TypePeakfinder8Info dictionary). required adc_threshold float The minimum ADC threshold for peak detection. required minimum_snr float The minimum signal-to-noise ratio for peak detection. required min_pixel_count int The minimum size of a peak in pixels. required max_pixel_count int The maximum size of a peak in pixels. required local_bg_radius int The radius for the estimation of the local background in pixels. required min_res int The minimum resolution for a peak in pixels. required max_res int The maximum resolution for a peak in pixels. required bad_pixel_map Optional[numpy.ndarray] An array storing a bad pixel map. The map can be used to mark areas of the data frame that must be excluded from the peak search. If the value of this argument is None, no area will be excluded from the search. Defaults to None. The map must be a numpy array of the same shape as the data frame on which the algorithm will be applied. Each pixel in the map must have a value of either 0, meaning that the corresponding pixel in the data frame should be ignored, or 1, meaning that the corresponding pixel should be included in the search. The map is only used to exclude areas from the peak search: the data is not modified in any way. required radius_pixel_map ndarray A numpy array with radius information. The array must have the same shape as the data frame on which the algorithm will be applied. Each element of the array must store, for the corresponding pixel in the data frame, the distance in pixels from the origin of the detector reference system (usually the center of the detector). required find_peaks ( self , data ) Finds peaks in a detector data frame. This function detects peaks in a data frame, and returns information about their location, size and intensity. Parameters: Name Type Description Default data ndarray The detector data frame on which the peak finding must be performed. required Returns: Type Description TypePeakList A TypePeakList dictionary with information about the detected peaks. TypePeakfinder8Info Detector layout information for the peakfinder8 algorithm. Base class: TypedDict This typed dictionary is used to store information about the data layout in a detector data frame, in the format needed by the Peakfinder8PeakDetection algorithm. This information is usually retrieved via the get_peakfinder8_info function. Attributes: Name Type Description asic_nx int The fs size in pixels of each detector panel in the data frame. asic_ny int The ss size in pixels of each detector panel in the data frame. nasics_x int The number of detector panels along the fs axis of the data frame. nasics_y int The number of detector panels along the ss axis of the data frame. TypePeakList Detected peaks information. This typed dictionary is used to store information about a set of peaks that were detected in a data frame. Attributes: Name Type Description num_peaks int The number of peaks that were detected in the data frame. fs List[float] A list of fractional fs indexes that locate the detected peaks in the data frame. ss List[float] A list of fractional ss indexes that locate the detected peaks in the data frame. intensity List[float] A list of integrated intensities for the detected peaks. num_pixels List[float] A list storing the number of pixels that make up each detected peak. max_pixel_intensity List[float] A list storing, for each peak, the value of the pixel with the maximum intensity. snr List[float] A list storing the signal-to-noise ratio of each detected peak. get_peakfinder8_info ( detector_type ) Gets the peakfinder8 information for a detector. This function retrieves, for a supported detector type, the data layout information required by the Peakfinder8PeakDetection algorithm. Parameters: Name Type Description Default detector_type str The type of detector for which the information needs to be retrieved. The following detector types are currently supported: 'cspad': The CSPAD detector used at the CXI beamline of the LCLS facility before 2020. 'pilatus': The Pilatus detector used at the P11 beamline of the PETRA III facility. 'jungfrau1M': The 1M version of the Jungfrau detector used at the PETRA III facility. 'jungfrau4M': The 4M version of the Jungfrau detector used at the CXI beamline of the LCLS facility. 'epix10k2M': The 2M version of the Epix10KA detector used at the MFX beamline of the LCLS facility. 'rayonix': The Rayonix detector used at the MFX beamline of the LCLS facility. required Returns: Type Description TypePeakfinder8Info A TypePeakfinder8Info dictionary storing the data layout information.","title":"crystallography"},{"location":"reference/om/algorithms/crystallography/#om.algorithms.crystallography","text":"Algorithms for the processing of crystallography data. This module contains algorithms that perform crystallography-related data processing (peak finding, etc.). In addition, it also contains several typed dictionaries that store data needed or produced by these algorithms.","title":"crystallography"},{"location":"reference/om/algorithms/crystallography/#om.algorithms.crystallography.Peakfinder8PeakDetection","text":"See documentation of the __init__ function.","title":"Peakfinder8PeakDetection"},{"location":"reference/om/algorithms/crystallography/#om.algorithms.crystallography.Peakfinder8PeakDetection.__init__","text":"Peakfinder8 algorithm for peak detection. This algorithm stores the parameters required to find peaks in a detector data frame using the 'peakfinder8' strategy, and performs peak finding on a data frame upon request. The 'peakfinder8' peak detection strategy is described in the following publication: A. Barty, R. A. Kirian, F. R. N. C. Maia, M. Hantke, C. H. Yoon, T. A. White, and H. N. Chapman, \"Cheetah: software for high-throughput reduction and analysis of serial femtosecond x-ray diffraction data\", J Appl Crystallogr, vol. 47, pp. 1118-1131 (2014). Parameters: Name Type Description Default max_num_peaks int The maximum number of peaks that will be retrieved from each data frame. Additional peaks will be ignored. required asic_nx int The fs size in pixels of each detector panel in the data frame (Can be retrieved from a TypePeakfinder8Info dictionary). required asic_ny int The ss size in pixels of each detector panel in the data frame (Can be retrieved from a TypePeakfinder8Info dictionary). required nasics_x int The number of panels along the fs axis of the data frame (Can be retrieved from a TypePeakfinder8Info dictionary). required nasics_y int The number of panels along the ss axis of the data frame (Can be retrieved from a TypePeakfinder8Info dictionary). required adc_threshold float The minimum ADC threshold for peak detection. required minimum_snr float The minimum signal-to-noise ratio for peak detection. required min_pixel_count int The minimum size of a peak in pixels. required max_pixel_count int The maximum size of a peak in pixels. required local_bg_radius int The radius for the estimation of the local background in pixels. required min_res int The minimum resolution for a peak in pixels. required max_res int The maximum resolution for a peak in pixels. required bad_pixel_map Optional[numpy.ndarray] An array storing a bad pixel map. The map can be used to mark areas of the data frame that must be excluded from the peak search. If the value of this argument is None, no area will be excluded from the search. Defaults to None. The map must be a numpy array of the same shape as the data frame on which the algorithm will be applied. Each pixel in the map must have a value of either 0, meaning that the corresponding pixel in the data frame should be ignored, or 1, meaning that the corresponding pixel should be included in the search. The map is only used to exclude areas from the peak search: the data is not modified in any way. required radius_pixel_map ndarray A numpy array with radius information. The array must have the same shape as the data frame on which the algorithm will be applied. Each element of the array must store, for the corresponding pixel in the data frame, the distance in pixels from the origin of the detector reference system (usually the center of the detector). required","title":"__init__()"},{"location":"reference/om/algorithms/crystallography/#om.algorithms.crystallography.Peakfinder8PeakDetection.find_peaks","text":"Finds peaks in a detector data frame. This function detects peaks in a data frame, and returns information about their location, size and intensity. Parameters: Name Type Description Default data ndarray The detector data frame on which the peak finding must be performed. required Returns: Type Description TypePeakList A TypePeakList dictionary with information about the detected peaks.","title":"find_peaks()"},{"location":"reference/om/algorithms/crystallography/#om.algorithms.crystallography.TypePeakfinder8Info","text":"Detector layout information for the peakfinder8 algorithm. Base class: TypedDict This typed dictionary is used to store information about the data layout in a detector data frame, in the format needed by the Peakfinder8PeakDetection algorithm. This information is usually retrieved via the get_peakfinder8_info function. Attributes: Name Type Description asic_nx int The fs size in pixels of each detector panel in the data frame. asic_ny int The ss size in pixels of each detector panel in the data frame. nasics_x int The number of detector panels along the fs axis of the data frame. nasics_y int The number of detector panels along the ss axis of the data frame.","title":"TypePeakfinder8Info"},{"location":"reference/om/algorithms/crystallography/#om.algorithms.crystallography.TypePeakList","text":"Detected peaks information. This typed dictionary is used to store information about a set of peaks that were detected in a data frame. Attributes: Name Type Description num_peaks int The number of peaks that were detected in the data frame. fs List[float] A list of fractional fs indexes that locate the detected peaks in the data frame. ss List[float] A list of fractional ss indexes that locate the detected peaks in the data frame. intensity List[float] A list of integrated intensities for the detected peaks. num_pixels List[float] A list storing the number of pixels that make up each detected peak. max_pixel_intensity List[float] A list storing, for each peak, the value of the pixel with the maximum intensity. snr List[float] A list storing the signal-to-noise ratio of each detected peak.","title":"TypePeakList"},{"location":"reference/om/algorithms/crystallography/#om.algorithms.crystallography.get_peakfinder8_info","text":"Gets the peakfinder8 information for a detector. This function retrieves, for a supported detector type, the data layout information required by the Peakfinder8PeakDetection algorithm. Parameters: Name Type Description Default detector_type str The type of detector for which the information needs to be retrieved. The following detector types are currently supported: 'cspad': The CSPAD detector used at the CXI beamline of the LCLS facility before 2020. 'pilatus': The Pilatus detector used at the P11 beamline of the PETRA III facility. 'jungfrau1M': The 1M version of the Jungfrau detector used at the PETRA III facility. 'jungfrau4M': The 4M version of the Jungfrau detector used at the CXI beamline of the LCLS facility. 'epix10k2M': The 2M version of the Epix10KA detector used at the MFX beamline of the LCLS facility. 'rayonix': The Rayonix detector used at the MFX beamline of the LCLS facility. required Returns: Type Description TypePeakfinder8Info A TypePeakfinder8Info dictionary storing the data layout information.","title":"get_peakfinder8_info()"},{"location":"reference/om/algorithms/generic/","text":"generic Generic algorithms. This module contains algorithms that perform generic processing the data: common operations that are not tied to a specific experimental technique (e.g.: detector frame masking and correction, data accumulation, etc.). Correction See documentation of the __init__ function. __init__ ( self , dark_filename = None , dark_hdf5_path = None , mask_filename = None , mask_hdf5_path = None , gain_filename = None , gain_hdf5_path = None ) special Detector data frame correction. This algorithm can store a dark data frame, a bad pixel mask, and a gain map (all three are optionals). Upon request, it can apply all of these to a detector data frame. Parameters: Name Type Description Default dark_filename Optional[str] The relative or absolute path to an HDF5 file containing a dark data frame. Defaults to None. If this and the 'dark_hdf5_path' arguments are not None, the dark data is loaded and used by the algorithm. The dark data frame must be a numpy array of the same shape as the data frame on which the algorithm will be applied. None dark_hdf5_path Optional[str] The internal HDF5 path to the data block where the dark data frame is located. Defaults to None. If the 'dark_filename' argument is not None, this argument must also be provided, and cannot be None. Otherwise it is ignored. None mask_filename Optional[str] The relative or absolute path to an HDF5 file containing a mask. Defaults to None. If this and the 'mask_hdf5_path' arguments are not None, the mask is loaded and used by the algorithm. The mask data must be a numpy array of the same shape as the data frame on which the algorithm will be applied. Each pixel in the mask must have a value of either 0, meaning that the corresponding pixel in the data frame should be set to 0, or 1, meaning that the value of the corresponding pixel should be left alone. None mask_hdf5_path Optional[str] The internal HDF5 path to the data block where the mask data is located. Defaults to None. If the 'mask_filename' argument is not None, this argument must also be provided, and cannot be None. Otherwise it is ignored. None gain_filename Optional[str] The relative or absolute path to an HDF5 file containing a gain map. Defaults to None. If this and the 'gain_hdf5_path' arguments are not None, the gain map is loaded and used by the algorithm. The map must be a numpy array of the same shape as the data frame on which the algorithm will be applied. Each pixel in the gain map must store the gain factor that will be applied to the corresponding pixel in the data frame. None gain_hdf5_path Optional[str] The internal HDF5 path to the data block where the gain map data is located. Defaults to None. If the 'gain_filename' argument is not None, this argument must also be provided, and cannot be None. Otherwise it is ignored. None apply_correction ( self , data ) Applies the correction to a detector data frame. This function initially applies the mask, if provided, to the data frame. The dark data, if provided, is then subtracted. Finally, the result is multiplied by the gain map, again only if the latter is provided. Parameters: Name Type Description Default data ndarray The detector data frame on which the correction must be applied. required Returns: Type Description ndarray The corrected data. DataAccumulator See documentation of the __init__ function. __init__ ( self , num_events_to_accumulate ) special Data accumulation and bulk retrieval. This algorithm accumulates a predefined number of data entries (each data entry must have the format of a dictionary). When the right number of entries has been added to the accumulator, the collected data is returned to the user in bulk, and the accumulator resets. Parameters: Name Type Description Default num_events_to_accumulate int the number of data entries that can be added to the accumulator before the collected data is returned. required add_data ( self , data ) Adds data to the accumulator. If the accumulator, after adding the data, reaches the predefined number of entries, this function additionally resets the accumulator and returns the collected data. Parameters: Name Type Description Default data Dict[str, Any] A data entry to be added to the accumulator. required Returns: Type Description Optional[List[Dict[str, Any]]] Either a list containing the accumulated data (if the accumulator is reset), or None, if more data entries can still be added to the accumulator.","title":"generic"},{"location":"reference/om/algorithms/generic/#om.algorithms.generic","text":"Generic algorithms. This module contains algorithms that perform generic processing the data: common operations that are not tied to a specific experimental technique (e.g.: detector frame masking and correction, data accumulation, etc.).","title":"generic"},{"location":"reference/om/algorithms/generic/#om.algorithms.generic.Correction","text":"See documentation of the __init__ function.","title":"Correction"},{"location":"reference/om/algorithms/generic/#om.algorithms.generic.Correction.__init__","text":"Detector data frame correction. This algorithm can store a dark data frame, a bad pixel mask, and a gain map (all three are optionals). Upon request, it can apply all of these to a detector data frame. Parameters: Name Type Description Default dark_filename Optional[str] The relative or absolute path to an HDF5 file containing a dark data frame. Defaults to None. If this and the 'dark_hdf5_path' arguments are not None, the dark data is loaded and used by the algorithm. The dark data frame must be a numpy array of the same shape as the data frame on which the algorithm will be applied. None dark_hdf5_path Optional[str] The internal HDF5 path to the data block where the dark data frame is located. Defaults to None. If the 'dark_filename' argument is not None, this argument must also be provided, and cannot be None. Otherwise it is ignored. None mask_filename Optional[str] The relative or absolute path to an HDF5 file containing a mask. Defaults to None. If this and the 'mask_hdf5_path' arguments are not None, the mask is loaded and used by the algorithm. The mask data must be a numpy array of the same shape as the data frame on which the algorithm will be applied. Each pixel in the mask must have a value of either 0, meaning that the corresponding pixel in the data frame should be set to 0, or 1, meaning that the value of the corresponding pixel should be left alone. None mask_hdf5_path Optional[str] The internal HDF5 path to the data block where the mask data is located. Defaults to None. If the 'mask_filename' argument is not None, this argument must also be provided, and cannot be None. Otherwise it is ignored. None gain_filename Optional[str] The relative or absolute path to an HDF5 file containing a gain map. Defaults to None. If this and the 'gain_hdf5_path' arguments are not None, the gain map is loaded and used by the algorithm. The map must be a numpy array of the same shape as the data frame on which the algorithm will be applied. Each pixel in the gain map must store the gain factor that will be applied to the corresponding pixel in the data frame. None gain_hdf5_path Optional[str] The internal HDF5 path to the data block where the gain map data is located. Defaults to None. If the 'gain_filename' argument is not None, this argument must also be provided, and cannot be None. Otherwise it is ignored. None","title":"__init__()"},{"location":"reference/om/algorithms/generic/#om.algorithms.generic.Correction.apply_correction","text":"Applies the correction to a detector data frame. This function initially applies the mask, if provided, to the data frame. The dark data, if provided, is then subtracted. Finally, the result is multiplied by the gain map, again only if the latter is provided. Parameters: Name Type Description Default data ndarray The detector data frame on which the correction must be applied. required Returns: Type Description ndarray The corrected data.","title":"apply_correction()"},{"location":"reference/om/algorithms/generic/#om.algorithms.generic.DataAccumulator","text":"See documentation of the __init__ function.","title":"DataAccumulator"},{"location":"reference/om/algorithms/generic/#om.algorithms.generic.DataAccumulator.__init__","text":"Data accumulation and bulk retrieval. This algorithm accumulates a predefined number of data entries (each data entry must have the format of a dictionary). When the right number of entries has been added to the accumulator, the collected data is returned to the user in bulk, and the accumulator resets. Parameters: Name Type Description Default num_events_to_accumulate int the number of data entries that can be added to the accumulator before the collected data is returned. required","title":"__init__()"},{"location":"reference/om/algorithms/generic/#om.algorithms.generic.DataAccumulator.add_data","text":"Adds data to the accumulator. If the accumulator, after adding the data, reaches the predefined number of entries, this function additionally resets the accumulator and returns the collected data. Parameters: Name Type Description Default data Dict[str, Any] A data entry to be added to the accumulator. required Returns: Type Description Optional[List[Dict[str, Any]]] Either a list containing the accumulated data (if the accumulator is reset), or None, if more data entries can still be added to the accumulator.","title":"add_data()"},{"location":"reference/om/data_retrieval_layer/","text":"data_retrieval_layer special OM's ta Retrieval Layer package. This package contains OM's Data Retrieval Layer, with Data Event Handlers and Data Extraction Functions supporting several facilities. Functions and classes for different detectors and software frameworks are implemented in separate modules that are imported on-demand when OM starts. base data_handlers_filesystem data_handlers_hidra data_handlers_psana functions_cspad functions_epix10ka functions_jungfrau1M functions_jungfrau4M functions_pilatus functions_rayonix functions_psana","title":"__init__"},{"location":"reference/om/data_retrieval_layer/#om.data_retrieval_layer","text":"OM's ta Retrieval Layer package. This package contains OM's Data Retrieval Layer, with Data Event Handlers and Data Extraction Functions supporting several facilities. Functions and classes for different detectors and software frameworks are implemented in separate modules that are imported on-demand when OM starts. base data_handlers_filesystem data_handlers_hidra data_handlers_psana functions_cspad functions_epix10ka functions_jungfrau1M functions_jungfrau4M functions_pilatus functions_rayonix functions_psana","title":"data_retrieval_layer"},{"location":"reference/om/data_retrieval_layer/base/","text":"base Data Extraction Layer's base classes. This module contains base abstract classes for OM's Data Extraction Layer. OmDataEventHandler See documentation of the __init__ function. Base class: ABC data_extraction_funcs : Dict [ str , Callable [[ Dict [ str , Dict [ str , Any ]]], Any ]] property readonly Data Extraction Functions for the Data Event Handler. This property can be used to retrieve the Data Extractions Functions that are available to the Data Event Handler. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the Data Extraction Functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation. __init__ ( self , source , monitor_parameters , additional_info = {}) special Base class for an OM's Data Event Handler. Data Event Handlers are classes that deal with data events and data event sources in OM. They have methods to initialize sources, retrieve events from them, open and close events, and examine their content. This class is the base abstract class from which every Data Event Handler should inherit. All its methods are abstract. Each derived class must provide his own specific implementation that deals with a specific facility, detector or software framework. The only exception is the extract_data which works the same way in all Data Event Handlers. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file.. required source str A string describing the data source. required additional_info Dict[str, Any] A dictionary storing any additional information needed for the initialization of the Data Event Handler. {} close_event ( self , event ) Closes an event. This function processes a data event in such a way that the event is ready to be discared by OM. OM calls this function on each processing node after the extract_data function. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required event_generator ( self , node_rank , node_pool_size ) Retrieves events from the source. This function retrieves data events from a source. OM calls this function on each processing node when it starts to retrieve events. The function is a generator and it returns an iterator over the events that the calling node should process. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Yields: A dictionary storing the data for the current event. extract_data ( self , event ) Extracts data from a frame stored in an event. This function extracts data from a frame stored in an event. It works by calling, one after the other, all the Data Extraction Functions associated with the event, passing the event itself as input to each of them. The data extracted by each function is collected and returned to the caller. After retrieving a data event, OM calls this function on each frame in the event in sequence. The function is invoked each time on the full event: an internal flag keeps track of which frame should be processed in any given call. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description Dict[str, Any] A dictionary storing the data returned by the Data Extraction Functions. Each dictionary key identifies the Data Extraction Function used to extract the data. The corresponding dictionary value stores the data returned by the function. get_num_frames_in_event ( self , event ) Gets the number of detector frames in an event. This function returns the number of detector frames stored in a data event. OM calls it after each data event is retrieved to determine how many frames it contains. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description int The number of frames in the event. initialize_event_handling_on_collecting_node ( self , node_rank , node_pool_size ) Initializes event handling on the collecting node. This function is called on the collecting node when OM starts, and initializes the data event handling on the node. The function can return a initialization token if the data source requires it. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. initialize_event_handling_on_processing_node ( self , node_rank , node_pool_size ) Initializes event handling on a processing node. This function is called on a processing node when OM starts and initializes the data event handling on the node. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. open_event ( self , event ) Opens an event. This function processes a data event in such a way that the content of the event is retrievable by OM. OM calls this function on each processing node before the extract_data function. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required filter_data_extraction_funcs ( data_extraction_funcs , required_data ) Filters the list of Data Extraction Functions based on the required data. This function takes a dictionary with a set of Data Extraction Functions as input, in addition to a list of required data entries. It returns a dictionary containing only the mimimal subset of Data Extraction Functions needed to retrieve the required data. Parameters: Name Type Description Default data_extraction_funcs Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary containing a set of Data Extraction Functions. Each dictionary key must define the name of a function. The corresponding dictionary value must store the function implementation. required required_data List[str] A list of required data entries, used to select the necessary Data Extraction Functions. required Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary containing only the required Data Extraction Functions. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"base"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base","text":"Data Extraction Layer's base classes. This module contains base abstract classes for OM's Data Extraction Layer.","title":"base"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler","text":"See documentation of the __init__ function. Base class: ABC","title":"OmDataEventHandler"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.data_extraction_funcs","text":"Data Extraction Functions for the Data Event Handler. This property can be used to retrieve the Data Extractions Functions that are available to the Data Event Handler. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the Data Extraction Functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"data_extraction_funcs"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.__init__","text":"Base class for an OM's Data Event Handler. Data Event Handlers are classes that deal with data events and data event sources in OM. They have methods to initialize sources, retrieve events from them, open and close events, and examine their content. This class is the base abstract class from which every Data Event Handler should inherit. All its methods are abstract. Each derived class must provide his own specific implementation that deals with a specific facility, detector or software framework. The only exception is the extract_data which works the same way in all Data Event Handlers. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file.. required source str A string describing the data source. required additional_info Dict[str, Any] A dictionary storing any additional information needed for the initialization of the Data Event Handler. {}","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.close_event","text":"Closes an event. This function processes a data event in such a way that the event is ready to be discared by OM. OM calls this function on each processing node after the extract_data function. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"close_event()"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.event_generator","text":"Retrieves events from the source. This function retrieves data events from a source. OM calls this function on each processing node when it starts to retrieve events. The function is a generator and it returns an iterator over the events that the calling node should process. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Yields: A dictionary storing the data for the current event.","title":"event_generator()"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.extract_data","text":"Extracts data from a frame stored in an event. This function extracts data from a frame stored in an event. It works by calling, one after the other, all the Data Extraction Functions associated with the event, passing the event itself as input to each of them. The data extracted by each function is collected and returned to the caller. After retrieving a data event, OM calls this function on each frame in the event in sequence. The function is invoked each time on the full event: an internal flag keeps track of which frame should be processed in any given call. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description Dict[str, Any] A dictionary storing the data returned by the Data Extraction Functions. Each dictionary key identifies the Data Extraction Function used to extract the data. The corresponding dictionary value stores the data returned by the function.","title":"extract_data()"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.get_num_frames_in_event","text":"Gets the number of detector frames in an event. This function returns the number of detector frames stored in a data event. OM calls it after each data event is retrieved to determine how many frames it contains. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description int The number of frames in the event.","title":"get_num_frames_in_event()"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.initialize_event_handling_on_collecting_node","text":"Initializes event handling on the collecting node. This function is called on the collecting node when OM starts, and initializes the data event handling on the node. The function can return a initialization token if the data source requires it. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token.","title":"initialize_event_handling_on_collecting_node()"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.initialize_event_handling_on_processing_node","text":"Initializes event handling on a processing node. This function is called on a processing node when OM starts and initializes the data event handling on the node. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token.","title":"initialize_event_handling_on_processing_node()"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.OmDataEventHandler.open_event","text":"Opens an event. This function processes a data event in such a way that the content of the event is retrievable by OM. OM calls this function on each processing node before the extract_data function. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"open_event()"},{"location":"reference/om/data_retrieval_layer/base/#om.data_retrieval_layer.base.filter_data_extraction_funcs","text":"Filters the list of Data Extraction Functions based on the required data. This function takes a dictionary with a set of Data Extraction Functions as input, in addition to a list of required data entries. It returns a dictionary containing only the mimimal subset of Data Extraction Functions needed to retrieve the required data. Parameters: Name Type Description Default data_extraction_funcs Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary containing a set of Data Extraction Functions. Each dictionary key must define the name of a function. The corresponding dictionary value must store the function implementation. required required_data List[str] A list of required data entries, used to select the necessary Data Extraction Functions. required Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary containing only the required Data Extraction Functions. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"filter_data_extraction_funcs()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/","text":"data_handlers_filesystem Retrieval and handling of data events from a filesystem. This module contains Data Event Handlers for files saved in a filesystem (on a physical or virtual disk). FilesBaseDataEventHandler See documentation of the __init__ function. Base class: OmDataEventHandler __init__ ( self , monitor_parameters , source ) special Base Data Event Handler class for events retrieved from files. This is the base class for Data Event Handlers that deal with files. It is a subclass of the more generic OmDataEventHandler base class, and should in turn be subclassed to implement Data Event Handlers for specific file types. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required initialize_event_handling_on_collecting_node ( self , node_rank , node_pool_size ) Initializes file event handling on the collecting node. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. There is usually no need to initialize a file-based data source on the collecting node, so this function actually does nothing. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. Jungfrau1MFilesDataEventHandler See documentation of the __init__ function. Base class: FilesBaseDataEventHandler data_extraction_funcs : Dict [ str , Callable [[ Dict [ str , Dict [ str , Any ]]], Any ]] property readonly Retrieves the Data Extraction Functions for Jungfrau 1M file events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the Data Extraction functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation. __init__ ( self , monitor_parameters , source ) special Data Event Handler for Jungfrau 1M files. This Data Event Handler deals with files written by a Jungfrau 1M detector in HDF5 format. It is a subclass of the FilesBaseDataEventHandler class. The source string for this Data Event Handler is a path to a file containing a list of HDF5 files to process, one per line, with their absolute or relative path. Each file stores multiple detector data frames. Each retrieved event corresponds to a single frame from a file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required close_event ( self , event ) Closes a Jungfrau 1M file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Since each detector frame in a file is considered a separate event, the event generator, which splits the frames across the processing nodes, takes care of opening and closing the files. This function therefore does nothing. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required event_generator ( self , node_rank , node_pool_size ) Retrieves Jungfrau 1M file events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This Event Data Handler considers each detector frame, not each file, a separate event. The frames retrieved from the data source are split as evenly as possible across all the processing nodes. Each node ideally retrieves the same number of frames from the source. Only the last node might retrieve fewer frames, depending on how evenly the total number can be split. This generator function yields a dictionary storing the data for the current event. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required get_num_frames_in_event ( self , event ) Gets the number of frames in a Jungfrau 1M file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Since each frame in a file is considered a separate event, this function always returns 1. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description int The number of frames in the event. initialize_event_handling_on_processing_node ( self , node_rank , node_pool_size ) Initializes Jungfrau 1M file event handling on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. open_event ( self , event ) Opens a Jungfrau 1M file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Since each detector frame in a file is considered a separate event, the event generator, which splits the frames across the processing nodes, takes care of opening and closing the files. This function therefore does nothing. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required PilatusFilesDataEventHandler See documentation of the __init__ function. Base class: FilesBaseDataEventHandler data_extraction_funcs : Dict [ str , Callable [[ Dict [ str , Dict [ str , Any ]]], Any ]] property readonly Retrieves the Data Extraction Functions for Pilatus file events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the Data Extraction functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation. __init__ ( self , monitor_parameters , source ) special Data Event Handler for Pilatus files. This Data Event Handler deals with files written by a 1M Pilatus detector in CBF format. It is a subclass of the FilesBaseDataEventHandler class. The source string for this Data Event Handler is a path to a file containing a list of CBF files to process, one per line, with their absolute or relative path. Each retrieved event corresponds to the content of one CBF file, which usually stores a single detector data frame. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required close_event ( self , event ) Closes a Pilatus file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. CBF files don't need to be closed, therefore this function does nothing. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required event_generator ( self , node_rank , node_pool_size ) Retrieves Pilatus file events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This Data Event Handler distributes the files from the data source as evenly as possible across all the processing nodes. Each node ideally retrieves the same number of files from the source. Only the last node might retrieve fewer files, depending on how evenly the total number can be split. This generator function yields a dictionary storing the data for the current event. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required get_num_frames_in_event ( self , event ) Gets the number of frames in a Pilatus file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Since a Pilatus detector usually writes only one frame per file, this function always returns 1. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description int The number of frames in the event. initialize_event_handling_on_processing_node ( self , node_rank , node_pool_size ) Initializes Pilatus file event handling on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. open_event ( self , event ) Opens a Pilatus file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function opens each CBF file and associates its content with the 'data' key of the 'event' dictionary. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"data_handlers_filesystem"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem","text":"Retrieval and handling of data events from a filesystem. This module contains Data Event Handlers for files saved in a filesystem (on a physical or virtual disk).","title":"data_handlers_filesystem"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.FilesBaseDataEventHandler","text":"See documentation of the __init__ function. Base class: OmDataEventHandler","title":"FilesBaseDataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.FilesBaseDataEventHandler.__init__","text":"Base Data Event Handler class for events retrieved from files. This is the base class for Data Event Handlers that deal with files. It is a subclass of the more generic OmDataEventHandler base class, and should in turn be subclassed to implement Data Event Handlers for specific file types. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.FilesBaseDataEventHandler.initialize_event_handling_on_collecting_node","text":"Initializes file event handling on the collecting node. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. There is usually no need to initialize a file-based data source on the collecting node, so this function actually does nothing. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token.","title":"initialize_event_handling_on_collecting_node()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.Jungfrau1MFilesDataEventHandler","text":"See documentation of the __init__ function. Base class: FilesBaseDataEventHandler","title":"Jungfrau1MFilesDataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.Jungfrau1MFilesDataEventHandler.data_extraction_funcs","text":"Retrieves the Data Extraction Functions for Jungfrau 1M file events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the Data Extraction functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"data_extraction_funcs"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.Jungfrau1MFilesDataEventHandler.__init__","text":"Data Event Handler for Jungfrau 1M files. This Data Event Handler deals with files written by a Jungfrau 1M detector in HDF5 format. It is a subclass of the FilesBaseDataEventHandler class. The source string for this Data Event Handler is a path to a file containing a list of HDF5 files to process, one per line, with their absolute or relative path. Each file stores multiple detector data frames. Each retrieved event corresponds to a single frame from a file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.Jungfrau1MFilesDataEventHandler.close_event","text":"Closes a Jungfrau 1M file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Since each detector frame in a file is considered a separate event, the event generator, which splits the frames across the processing nodes, takes care of opening and closing the files. This function therefore does nothing. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"close_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.Jungfrau1MFilesDataEventHandler.event_generator","text":"Retrieves Jungfrau 1M file events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This Event Data Handler considers each detector frame, not each file, a separate event. The frames retrieved from the data source are split as evenly as possible across all the processing nodes. Each node ideally retrieves the same number of frames from the source. Only the last node might retrieve fewer frames, depending on how evenly the total number can be split. This generator function yields a dictionary storing the data for the current event. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"event_generator()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.Jungfrau1MFilesDataEventHandler.get_num_frames_in_event","text":"Gets the number of frames in a Jungfrau 1M file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Since each frame in a file is considered a separate event, this function always returns 1. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description int The number of frames in the event.","title":"get_num_frames_in_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.Jungfrau1MFilesDataEventHandler.initialize_event_handling_on_processing_node","text":"Initializes Jungfrau 1M file event handling on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token.","title":"initialize_event_handling_on_processing_node()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.Jungfrau1MFilesDataEventHandler.open_event","text":"Opens a Jungfrau 1M file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Since each detector frame in a file is considered a separate event, the event generator, which splits the frames across the processing nodes, takes care of opening and closing the files. This function therefore does nothing. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"open_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.PilatusFilesDataEventHandler","text":"See documentation of the __init__ function. Base class: FilesBaseDataEventHandler","title":"PilatusFilesDataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.PilatusFilesDataEventHandler.data_extraction_funcs","text":"Retrieves the Data Extraction Functions for Pilatus file events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the Data Extraction functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"data_extraction_funcs"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.PilatusFilesDataEventHandler.__init__","text":"Data Event Handler for Pilatus files. This Data Event Handler deals with files written by a 1M Pilatus detector in CBF format. It is a subclass of the FilesBaseDataEventHandler class. The source string for this Data Event Handler is a path to a file containing a list of CBF files to process, one per line, with their absolute or relative path. Each retrieved event corresponds to the content of one CBF file, which usually stores a single detector data frame. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.PilatusFilesDataEventHandler.close_event","text":"Closes a Pilatus file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. CBF files don't need to be closed, therefore this function does nothing. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"close_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.PilatusFilesDataEventHandler.event_generator","text":"Retrieves Pilatus file events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This Data Event Handler distributes the files from the data source as evenly as possible across all the processing nodes. Each node ideally retrieves the same number of files from the source. Only the last node might retrieve fewer files, depending on how evenly the total number can be split. This generator function yields a dictionary storing the data for the current event. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"event_generator()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.PilatusFilesDataEventHandler.get_num_frames_in_event","text":"Gets the number of frames in a Pilatus file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Since a Pilatus detector usually writes only one frame per file, this function always returns 1. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description int The number of frames in the event.","title":"get_num_frames_in_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.PilatusFilesDataEventHandler.initialize_event_handling_on_processing_node","text":"Initializes Pilatus file event handling on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token.","title":"initialize_event_handling_on_processing_node()"},{"location":"reference/om/data_retrieval_layer/data_handlers_filesystem/#om.data_retrieval_layer.data_handlers_filesystem.PilatusFilesDataEventHandler.open_event","text":"Opens a Pilatus file event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function opens each CBF file and associates its content with the 'data' key of the 'event' dictionary. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"open_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/","text":"data_handlers_hidra Retrieval and handling of data events from HiDRA. This module contains Data Event Handlers for events retrieved from the HiDRA software framework (used at the Petra III facility). P11Petra3DataEventHandler See documentation of the __init__ function. Base class: OmDataEventHandler data_extraction_funcs : Dict [ str , Callable [[ Dict [ str , Dict [ str , Any ]]], Any ]] property readonly Retrieves the Data Extraction Functions for HiDRA events at P11. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the Data Extraction functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation. __init__ ( self , monitor_parameters , source ) special Data Event Handler for events retrieved from HiDRA at P11 (PETRA III). This Data Event Handler deals with events retrieved from the HiDRA software framework at the P11 beamline of the Petra III facility. It is a subclass of the generic OmDataEventHandler base class. The source string for this Data Event Handler is the host name or IP address of the machine where the HiDRA server is running. HiDRA streams events based on files written by detectors, with each event usually corresponding to the content of one file. At P11, the x-ray detector is a 1M Pilatus. This detector writes files in CBF format. Each HiDRA event therefore corresponds to the content of a single CBF file, which usually stores 1 detector frame. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required close_event ( self , event ) Closes a P11 HiDRA data event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. An event recovered from HiDRA at P11 does not need to be closed, therefore this function does nothing.. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required event_generator ( self , node_rank , node_pool_size ) Retrieves HiDRA events at P11. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function retrieves events from the HiDRA server. At the P11 beamline of the Petra III facility, each HiDRA event corresponds to the content of a single CBF file written by a Pilatus 1M detector. This generator function yields a dictionary storing the data for the current event. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Exceptions: Type Description OmHidraAPIError A OmHidraAPIError exception is raised if the initial connection to HiDRA fails. get_num_frames_in_event ( self , event ) Gets the number of frames in a P11 HiDRA data event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. At P11, each HiDRA event contains data from a single CBF file from a 1M Pilatus detector. These files usually store just one detector frame. This function therefore always returns 1. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required initialize_event_handling_on_collecting_node ( self , node_rank , node_pool_size ) Initializes P11 HiDRA event handling on the collecting node. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function announces OM to the HiDRA server. It configures HiDRA to send data events to the processing nodes. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. Exceptions: Type Description OmHidraAPIError A OmHidraAPIError exception is raised if the initial connection to HiDRA fails. initialize_event_handling_on_processing_node ( self , node_rank , node_pool_size ) Initializes P11 HiDRA event handling on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function configures each processing node to receive events from the HiDRA server. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Exceptions: Type Description OmHidraAPIError A OmHidraAPIError exception is raised if the initial connection to HiDRA fails. open_event ( self , event ) Opens a P11 HiDRA event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. At P11, each HiDRA event contains data from a single CBF file from a 1M Pilatus detector. This function associates the content of the CBF file to the 'data' key of the 'event' dictionary. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"data_handlers_hidra"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra","text":"Retrieval and handling of data events from HiDRA. This module contains Data Event Handlers for events retrieved from the HiDRA software framework (used at the Petra III facility).","title":"data_handlers_hidra"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler","text":"See documentation of the __init__ function. Base class: OmDataEventHandler","title":"P11Petra3DataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler.data_extraction_funcs","text":"Retrieves the Data Extraction Functions for HiDRA events at P11. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the Data Extraction functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"data_extraction_funcs"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler.__init__","text":"Data Event Handler for events retrieved from HiDRA at P11 (PETRA III). This Data Event Handler deals with events retrieved from the HiDRA software framework at the P11 beamline of the Petra III facility. It is a subclass of the generic OmDataEventHandler base class. The source string for this Data Event Handler is the host name or IP address of the machine where the HiDRA server is running. HiDRA streams events based on files written by detectors, with each event usually corresponding to the content of one file. At P11, the x-ray detector is a 1M Pilatus. This detector writes files in CBF format. Each HiDRA event therefore corresponds to the content of a single CBF file, which usually stores 1 detector frame. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler.close_event","text":"Closes a P11 HiDRA data event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. An event recovered from HiDRA at P11 does not need to be closed, therefore this function does nothing.. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"close_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler.event_generator","text":"Retrieves HiDRA events at P11. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function retrieves events from the HiDRA server. At the P11 beamline of the Petra III facility, each HiDRA event corresponds to the content of a single CBF file written by a Pilatus 1M detector. This generator function yields a dictionary storing the data for the current event. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Exceptions: Type Description OmHidraAPIError A OmHidraAPIError exception is raised if the initial connection to HiDRA fails.","title":"event_generator()"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler.get_num_frames_in_event","text":"Gets the number of frames in a P11 HiDRA data event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. At P11, each HiDRA event contains data from a single CBF file from a 1M Pilatus detector. These files usually store just one detector frame. This function therefore always returns 1. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"get_num_frames_in_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler.initialize_event_handling_on_collecting_node","text":"Initializes P11 HiDRA event handling on the collecting node. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function announces OM to the HiDRA server. It configures HiDRA to send data events to the processing nodes. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. Exceptions: Type Description OmHidraAPIError A OmHidraAPIError exception is raised if the initial connection to HiDRA fails.","title":"initialize_event_handling_on_collecting_node()"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler.initialize_event_handling_on_processing_node","text":"Initializes P11 HiDRA event handling on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function configures each processing node to receive events from the HiDRA server. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Exceptions: Type Description OmHidraAPIError A OmHidraAPIError exception is raised if the initial connection to HiDRA fails.","title":"initialize_event_handling_on_processing_node()"},{"location":"reference/om/data_retrieval_layer/data_handlers_hidra/#om.data_retrieval_layer.data_handlers_hidra.P11Petra3DataEventHandler.open_event","text":"Opens a P11 HiDRA event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. At P11, each HiDRA event contains data from a single CBF file from a 1M Pilatus detector. This function associates the content of the CBF file to the 'data' key of the 'event' dictionary. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required","title":"open_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/","text":"data_handlers_psana Retrieval and handling of data events from psana. This module contains Data Event Handlers for events retrieved from the psana software framework (used at the LCLS facility). CxiLclsCspadDataEventHandler See documentation of the __init__ function. Base class: LclsBaseDataEventHandler data_extraction_funcs : Dict [ str , Callable [[ Dict [ str , Dict [ str , Any ]]], Any ]] property readonly Retrieves the Data Extraction Functions for CXI psana events (CSPAD). This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the implementations of the Data Extraction functions available to the current DataEventHandler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation. __init__ ( self , monitor_parameters , source ) special Data Event Handler for events retrieved from psana at CXI with CSPAD (LCLS). This Data Event Handler deals with events retrieved from psana at the CXI beamline of the LCLS facility before 2020, when a CSPAD was the main x-ray detector. Is is a subclass of the LclsBaseDataEventHandler class. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required CxiLclsDataEventHandler See documentation of the __init__ function. Base class: LclsBaseDataEventHandler data_extraction_funcs : Dict [ str , Callable [[ Dict [ str , Any ]], Any ]] property readonly Retrieves the Data Extraction Functions for CXI psana events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Any]], Any]] A dictionary storing the Data Extraction functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation. __init__ ( self , monitor_parameters , source ) special Data Event Handler for events retrieved from psana at CXI (LCLS). This Data Event Handler deals with events retrieved from psana at the CXI beamline of the LCLS facility from 2020, with a Jungfrau 4M as the main x-ray detector. Is is a subclass of the LclsBaseDataEventHandler class. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required LclsBaseDataEventHandler See documentation of the __init__ function. Base class: OmDataEventHandler __init__ ( self , monitor_parameters , source ) special Base Data Event Handler for events recovered from psana at LCLS. This is the base class for Data Event Handlers that deal with events retrieved from the psana software framework at the LCLS facility. It is a subclass of the more generic OmDataEventHandler base class and should in turn be subclassed to work with specific detectors or beamlines. The source string for this Data Event Handler is a string of the type used by the psana framework to identify specific runs, experiments, or live data streams. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required close_event ( self , event ) Closes a psana event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Psana events do not need to be closed, so this function actually does nothing. Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required event_generator ( self , node_rank , node_pool_size ) Retrieves psana events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. When OM runs in shared memory mode (the usual way to retrieve real-time data at the LCLS facility), each processing node retrieves data from a shared memory server operated by the facility. The memory server must be running on the same machine as the processing node. When instead OM uses the psana framework to read offline data, this Data Event Handler distributes the data events as evenly as possible across all the processing nodes. Each node ideally retrieves the same number of events from psana. Only the last node might retrieve fewer events, depending on how evenly the total number can be split. Each retrieved psana event contains a single detector frame, along with all the data whose timestamp matches the timestamp of the frame. This is also true for data that is is updated at a slower rate than the frame itself. For this kind of data, the last reported value at the time the frame is collected is associated with it. This generator function yields a dictionary storing the data for the current event. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required get_num_frames_in_event ( self , event ) Gets the number of frames in a psana event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Each psana event stores data related to a single detector frame, so this function always returns 1. Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required Returns: Type Description int int: the number of frames in the event. initialize_event_handling_on_collecting_node ( self , node_rank , node_pool_size ) Initializes psana event handling on the collecting node. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. The psana data source does not need to be initialized on the collecting node, therefore this function actually does nothing. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. initialize_event_handling_on_processing_node ( self , node_rank , node_pool_size ) Initializes psana event handling on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function prepares the processing node to retrieve events from psana, initializing all the members of the psana Detector interface according to the instructions specified in OM's configuration file. Please refer to the documentation of the each Detector interface initialization function for a description of the relevant configuration parameters. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token. open_event ( self , event ) Opens a psana event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Psana events do not need to be opened, so this function actually does nothing. Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required MfxLclsDataEventHandler See documentation of the __init__ function. Base class: LclsBaseDataEventHandler data_extraction_funcs : Dict [ str , Callable [[ Dict [ str , Any ]], Any ]] property readonly Retrieves the Data Extraction Functions for MFX psana events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Any]], Any]] A dictionary storing the implementations of the Data Extraction functions available to the current DataEventHandler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation. __init__ ( self , monitor_parameters , source ) special Data Event Handler for events retrieved from psana at MFX (LCLS). This Data Event Handler deals with events retrieved from psana at the MFX beamline of the LCLS facility, with an Epix10KA as the main x-ray detector. It is a subclass of the LclsBaseDataEventHandler class. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required MfxLclsRayonixDataEventHandler See documentation of the __init__ function. Base class: LclsBaseDataEventHandler data_extraction_funcs : Dict [ str , Callable [[ Dict [ str , Any ]], Any ]] property readonly Retrieves the Data Extraction Functions for MFX psana events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Any]], Any]] A dictionary storing the implementations of the Data Extraction functions available to the current DataEventHandler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation. __init__ ( self , monitor_parameters , source ) special Data Event Handler for events retrieved from psana at MFX with Rayonix (LCLS). This Data Event Handler deals with events retrieved from psana at the MFX beamline of the LCLS facility, with a Rayonix as the main x-ray detector. It is a subclass of the LclsBaseDataEventHandler class. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"data_handlers_psana"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana","text":"Retrieval and handling of data events from psana. This module contains Data Event Handlers for events retrieved from the psana software framework (used at the LCLS facility).","title":"data_handlers_psana"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.CxiLclsCspadDataEventHandler","text":"See documentation of the __init__ function. Base class: LclsBaseDataEventHandler","title":"CxiLclsCspadDataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.CxiLclsCspadDataEventHandler.data_extraction_funcs","text":"Retrieves the Data Extraction Functions for CXI psana events (CSPAD). This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Dict[str, Any]]], Any]] A dictionary storing the implementations of the Data Extraction functions available to the current DataEventHandler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"data_extraction_funcs"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.CxiLclsCspadDataEventHandler.__init__","text":"Data Event Handler for events retrieved from psana at CXI with CSPAD (LCLS). This Data Event Handler deals with events retrieved from psana at the CXI beamline of the LCLS facility before 2020, when a CSPAD was the main x-ray detector. Is is a subclass of the LclsBaseDataEventHandler class. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.CxiLclsDataEventHandler","text":"See documentation of the __init__ function. Base class: LclsBaseDataEventHandler","title":"CxiLclsDataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.CxiLclsDataEventHandler.data_extraction_funcs","text":"Retrieves the Data Extraction Functions for CXI psana events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Any]], Any]] A dictionary storing the Data Extraction functions available to the current Data Event Handler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"data_extraction_funcs"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.CxiLclsDataEventHandler.__init__","text":"Data Event Handler for events retrieved from psana at CXI (LCLS). This Data Event Handler deals with events retrieved from psana at the CXI beamline of the LCLS facility from 2020, with a Jungfrau 4M as the main x-ray detector. Is is a subclass of the LclsBaseDataEventHandler class. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.LclsBaseDataEventHandler","text":"See documentation of the __init__ function. Base class: OmDataEventHandler","title":"LclsBaseDataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.LclsBaseDataEventHandler.__init__","text":"Base Data Event Handler for events recovered from psana at LCLS. This is the base class for Data Event Handlers that deal with events retrieved from the psana software framework at the LCLS facility. It is a subclass of the more generic OmDataEventHandler base class and should in turn be subclassed to work with specific detectors or beamlines. The source string for this Data Event Handler is a string of the type used by the psana framework to identify specific runs, experiments, or live data streams. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.LclsBaseDataEventHandler.close_event","text":"Closes a psana event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Psana events do not need to be closed, so this function actually does nothing. Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required","title":"close_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.LclsBaseDataEventHandler.event_generator","text":"Retrieves psana events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. When OM runs in shared memory mode (the usual way to retrieve real-time data at the LCLS facility), each processing node retrieves data from a shared memory server operated by the facility. The memory server must be running on the same machine as the processing node. When instead OM uses the psana framework to read offline data, this Data Event Handler distributes the data events as evenly as possible across all the processing nodes. Each node ideally retrieves the same number of events from psana. Only the last node might retrieve fewer events, depending on how evenly the total number can be split. Each retrieved psana event contains a single detector frame, along with all the data whose timestamp matches the timestamp of the frame. This is also true for data that is is updated at a slower rate than the frame itself. For this kind of data, the last reported value at the time the frame is collected is associated with it. This generator function yields a dictionary storing the data for the current event. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"event_generator()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.LclsBaseDataEventHandler.get_num_frames_in_event","text":"Gets the number of frames in a psana event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Each psana event stores data related to a single detector frame, so this function always returns 1. Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required Returns: Type Description int int: the number of frames in the event.","title":"get_num_frames_in_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.LclsBaseDataEventHandler.initialize_event_handling_on_collecting_node","text":"Initializes psana event handling on the collecting node. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. The psana data source does not need to be initialized on the collecting node, therefore this function actually does nothing. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token.","title":"initialize_event_handling_on_collecting_node()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.LclsBaseDataEventHandler.initialize_event_handling_on_processing_node","text":"Initializes psana event handling on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function prepares the processing node to retrieve events from psana, initializing all the members of the psana Detector interface according to the instructions specified in OM's configuration file. Please refer to the documentation of the each Detector interface initialization function for a description of the relevant configuration parameters. Parameters: Name Type Description Default node_rank int The rank, in the OM pool, of the processing node calling the function. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Any An optional initialization token.","title":"initialize_event_handling_on_processing_node()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.LclsBaseDataEventHandler.open_event","text":"Opens a psana event. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Psana events do not need to be opened, so this function actually does nothing. Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required","title":"open_event()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.MfxLclsDataEventHandler","text":"See documentation of the __init__ function. Base class: LclsBaseDataEventHandler","title":"MfxLclsDataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.MfxLclsDataEventHandler.data_extraction_funcs","text":"Retrieves the Data Extraction Functions for MFX psana events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Any]], Any]] A dictionary storing the implementations of the Data Extraction functions available to the current DataEventHandler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"data_extraction_funcs"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.MfxLclsDataEventHandler.__init__","text":"Data Event Handler for events retrieved from psana at MFX (LCLS). This Data Event Handler deals with events retrieved from psana at the MFX beamline of the LCLS facility, with an Epix10KA as the main x-ray detector. It is a subclass of the LclsBaseDataEventHandler class. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.MfxLclsRayonixDataEventHandler","text":"See documentation of the __init__ function. Base class: LclsBaseDataEventHandler","title":"MfxLclsRayonixDataEventHandler"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.MfxLclsRayonixDataEventHandler.data_extraction_funcs","text":"Retrieves the Data Extraction Functions for MFX psana events. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. Returns: Type Description Dict[str, Callable[[Dict[str, Any]], Any]] A dictionary storing the implementations of the Data Extraction functions available to the current DataEventHandler. Each dictionary key defines the name of a function. The corresponding dictionary value stores the function implementation.","title":"data_extraction_funcs"},{"location":"reference/om/data_retrieval_layer/data_handlers_psana/#om.data_retrieval_layer.data_handlers_psana.MfxLclsRayonixDataEventHandler.__init__","text":"Data Event Handler for events retrieved from psana at MFX with Rayonix (LCLS). This Data Event Handler deals with events retrieved from psana at the MFX beamline of the LCLS facility, with a Rayonix as the main x-ray detector. It is a subclass of the LclsBaseDataEventHandler class. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required source str A string describing the data source. required","title":"__init__()"},{"location":"reference/om/data_retrieval_layer/functions_cspad/","text":"functions_cspad Retrieval of CSPAD detector data from psana. This module contains functions that retrieve CSPAD detector data from the psana software framework (used at the LCLS facility). detector_data ( event ) Retrieves a CSPAD detector data frame from psana. This function retrieves a single CSPAD detector frame from psana. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"functions_cspad"},{"location":"reference/om/data_retrieval_layer/functions_cspad/#om.data_retrieval_layer.functions_cspad","text":"Retrieval of CSPAD detector data from psana. This module contains functions that retrieve CSPAD detector data from the psana software framework (used at the LCLS facility).","title":"functions_cspad"},{"location":"reference/om/data_retrieval_layer/functions_cspad/#om.data_retrieval_layer.functions_cspad.detector_data","text":"Retrieves a CSPAD detector data frame from psana. This function retrieves a single CSPAD detector frame from psana. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"detector_data()"},{"location":"reference/om/data_retrieval_layer/functions_epix10ka/","text":"functions_epix10ka Retrieval of EPIX 2M detector data from psana. This module contains functions that retrieve EPIX 10K 2M detector data from the psana software framework (used at the LCLS facility). epixka2m_detector_data ( event ) Retrieves a Epix10KA 2M detector data frame from psana. This function retrieves a single EPIX10KA 2M detector frame from psana. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"functions_epix10ka"},{"location":"reference/om/data_retrieval_layer/functions_epix10ka/#om.data_retrieval_layer.functions_epix10ka","text":"Retrieval of EPIX 2M detector data from psana. This module contains functions that retrieve EPIX 10K 2M detector data from the psana software framework (used at the LCLS facility).","title":"functions_epix10ka"},{"location":"reference/om/data_retrieval_layer/functions_epix10ka/#om.data_retrieval_layer.functions_epix10ka.epixka2m_detector_data","text":"Retrieves a Epix10KA 2M detector data frame from psana. This function retrieves a single EPIX10KA 2M detector frame from psana. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"epixka2m_detector_data()"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau1M/","text":"functions_jungfrau1M Retrieval of Jungfrau 1M detector data from files. This module contains functions that retrieve Jungfrau 1M detector data from HDF5 files written by the detector itself. beam_energy ( event ) Gets the beam energy for a Jungfrau 1M event. The files written by the Jungfrau 1M detector do not provide beam energy information. Therefore OM uses the value provided for the 'fallback_beam_energy_in_eV' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The energy of the beam in eV. detector_data ( event ) Retrieves one Jungfrau 1M detector data frame from files. This function retrieves a single Jungfrau 1M frame from a set of HDF5 files written by the detector itself. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data. detector_distance ( event ) Gets the detector distance for a Jungfrau 1M event. The files written by the Jungfrau 1M detector do not provide detector distance information. Therefore OM uses the value provided for the 'fallback_detector_distance_in_mm' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The detector distance in mm. event_id ( event ) Gets a unique identifier for an event retrieved from a Jungfrau 1M detector. This function returns a label that unambiguously identifies, within an experiment, the data event currently being processed. For the Jungfrau 1M detector, the label is constructed by joining the following elements: The full path to the file containing the data for the first detector panel (d0) The index of the current frame within the file itself. The two parts of the label are separated by the \"//\" symbol. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique event identifier. frame_id ( event ) Gets a unique identifier for a Jungfrau 1M detector data frame. This function returns a label that unambiguously identifies, within an event, the frame currently being processed. For the Jungfrau 1M detector, each event corresponds to a single detector frame. The event label (returned by the event_id function) is therefore sufficient to unambiguously identify each frame. Because of this, this function always returns the string \"0\". Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required Returns: Type Description str A unique frame identifier (within an event). timestamp ( event ) Gets the timestamp of a Jungfrau 1M event. For the Jungfrau 1M detector, the timestamp for an event, which corresponds to a single detector frame, is defined according to the the creation times of the files from which the frame originates. The HDF5 file containing the data for the first detector panel (d0) is taken as reference. Its creation time is added to to the relative timestamp difference between the first frame in the file and the one being processed. The timestamp differences are determined by the detector's internal clock and stored in the HDF5 files themselves. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float64 The timestamp of the event in seconds from the Epoch.","title":"functions_jungfrau1M"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau1M/#om.data_retrieval_layer.functions_jungfrau1M","text":"Retrieval of Jungfrau 1M detector data from files. This module contains functions that retrieve Jungfrau 1M detector data from HDF5 files written by the detector itself.","title":"functions_jungfrau1M"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau1M/#om.data_retrieval_layer.functions_jungfrau1M.beam_energy","text":"Gets the beam energy for a Jungfrau 1M event. The files written by the Jungfrau 1M detector do not provide beam energy information. Therefore OM uses the value provided for the 'fallback_beam_energy_in_eV' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The energy of the beam in eV.","title":"beam_energy()"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau1M/#om.data_retrieval_layer.functions_jungfrau1M.detector_data","text":"Retrieves one Jungfrau 1M detector data frame from files. This function retrieves a single Jungfrau 1M frame from a set of HDF5 files written by the detector itself. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"detector_data()"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau1M/#om.data_retrieval_layer.functions_jungfrau1M.detector_distance","text":"Gets the detector distance for a Jungfrau 1M event. The files written by the Jungfrau 1M detector do not provide detector distance information. Therefore OM uses the value provided for the 'fallback_detector_distance_in_mm' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The detector distance in mm.","title":"detector_distance()"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau1M/#om.data_retrieval_layer.functions_jungfrau1M.event_id","text":"Gets a unique identifier for an event retrieved from a Jungfrau 1M detector. This function returns a label that unambiguously identifies, within an experiment, the data event currently being processed. For the Jungfrau 1M detector, the label is constructed by joining the following elements: The full path to the file containing the data for the first detector panel (d0) The index of the current frame within the file itself. The two parts of the label are separated by the \"//\" symbol. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique event identifier.","title":"event_id()"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau1M/#om.data_retrieval_layer.functions_jungfrau1M.frame_id","text":"Gets a unique identifier for a Jungfrau 1M detector data frame. This function returns a label that unambiguously identifies, within an event, the frame currently being processed. For the Jungfrau 1M detector, each event corresponds to a single detector frame. The event label (returned by the event_id function) is therefore sufficient to unambiguously identify each frame. Because of this, this function always returns the string \"0\". Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required Returns: Type Description str A unique frame identifier (within an event).","title":"frame_id()"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau1M/#om.data_retrieval_layer.functions_jungfrau1M.timestamp","text":"Gets the timestamp of a Jungfrau 1M event. For the Jungfrau 1M detector, the timestamp for an event, which corresponds to a single detector frame, is defined according to the the creation times of the files from which the frame originates. The HDF5 file containing the data for the first detector panel (d0) is taken as reference. Its creation time is added to to the relative timestamp difference between the first frame in the file and the one being processed. The timestamp differences are determined by the detector's internal clock and stored in the HDF5 files themselves. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float64 The timestamp of the event in seconds from the Epoch.","title":"timestamp()"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau4M/","text":"functions_jungfrau4M Retrieval of Jungfrau 4M detector data from psana. This module contains functions that retrieve Jungfrau 4M detector data from the psana software framework (used at the LCLS facility). detector_data ( event ) Retrieves one Jungfrau 4M detector data frame from psana. This function retrieves a single Jungfrau 4M detector frame from psana. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"functions_jungfrau4M"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau4M/#om.data_retrieval_layer.functions_jungfrau4M","text":"Retrieval of Jungfrau 4M detector data from psana. This module contains functions that retrieve Jungfrau 4M detector data from the psana software framework (used at the LCLS facility).","title":"functions_jungfrau4M"},{"location":"reference/om/data_retrieval_layer/functions_jungfrau4M/#om.data_retrieval_layer.functions_jungfrau4M.detector_data","text":"Retrieves one Jungfrau 4M detector data frame from psana. This function retrieves a single Jungfrau 4M detector frame from psana. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"detector_data()"},{"location":"reference/om/data_retrieval_layer/functions_pilatus/","text":"functions_pilatus Retrieval of Pilatus detector data from files or HiDRA. This module contains functions that retrieve Pilatus detector data from CBF files written by the detector itself, or from the HiDRA software framework (used at the Petra III facility). beam_energy ( event ) Gets the beam energy for a Pilatus event. Files written by the Pilatus detector and Pilatus data events retrieved from HiDRA usually do not provide beam energy information. OM uses the value provided for the 'fallback_beam_energy_in_eV' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The energy of the beam in eV. detector_data ( event ) Retrieves one Pilatus detector data frame from files or HiDRA. This function retrieves a single Pilatus detector frame from files or HiDRA. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data. detector_distance ( event ) Gets the detector distance for a Pilatus data event. Files written by the Pilatus detector and Pilatus data events retrieved from HiDRA usually do not provide beam energy information. OM uses the value provided for the 'fallback_detector_distance_in_mm' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required Returns: Type Description float float: the detector distance in mm. event_id ( event ) Gets a unique identifier for an event retrieved from a Pilatus detector. This function returns a label that unambiguously identifies, within an experiment, the event currently being processed. For the Pilatus detector, each HiDRA or file event corresponds to a single CBF data file and the full path to the file is used as a label. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique event identifier. frame_id ( event ) Gets a unique identifier for a Pilatus detector data frame. This function returns a label that unambiguously identifies, within an event, the frame currently being processed. Each Pilatus event only contains one frame, therefore this function always returns the string \"0\". Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique frame identifier (within an event). timestamp ( event ) Gets the timestamp of a Pilatus data event. For the Pilatus detector, each HiDRA or file event corresponds to a single CBF data file: the creation time of the file, retrieved from the filesystem or HiDRA, is used as a timestamp for the event. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float64 The timestamp of the event in seconds from the Epoch.","title":"functions_pilatus"},{"location":"reference/om/data_retrieval_layer/functions_pilatus/#om.data_retrieval_layer.functions_pilatus","text":"Retrieval of Pilatus detector data from files or HiDRA. This module contains functions that retrieve Pilatus detector data from CBF files written by the detector itself, or from the HiDRA software framework (used at the Petra III facility).","title":"functions_pilatus"},{"location":"reference/om/data_retrieval_layer/functions_pilatus/#om.data_retrieval_layer.functions_pilatus.beam_energy","text":"Gets the beam energy for a Pilatus event. Files written by the Pilatus detector and Pilatus data events retrieved from HiDRA usually do not provide beam energy information. OM uses the value provided for the 'fallback_beam_energy_in_eV' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The energy of the beam in eV.","title":"beam_energy()"},{"location":"reference/om/data_retrieval_layer/functions_pilatus/#om.data_retrieval_layer.functions_pilatus.detector_data","text":"Retrieves one Pilatus detector data frame from files or HiDRA. This function retrieves a single Pilatus detector frame from files or HiDRA. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"detector_data()"},{"location":"reference/om/data_retrieval_layer/functions_pilatus/#om.data_retrieval_layer.functions_pilatus.detector_distance","text":"Gets the detector distance for a Pilatus data event. Files written by the Pilatus detector and Pilatus data events retrieved from HiDRA usually do not provide beam energy information. OM uses the value provided for the 'fallback_detector_distance_in_mm' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] a dictionary storing the event data. required Returns: Type Description float float: the detector distance in mm.","title":"detector_distance()"},{"location":"reference/om/data_retrieval_layer/functions_pilatus/#om.data_retrieval_layer.functions_pilatus.event_id","text":"Gets a unique identifier for an event retrieved from a Pilatus detector. This function returns a label that unambiguously identifies, within an experiment, the event currently being processed. For the Pilatus detector, each HiDRA or file event corresponds to a single CBF data file and the full path to the file is used as a label. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique event identifier.","title":"event_id()"},{"location":"reference/om/data_retrieval_layer/functions_pilatus/#om.data_retrieval_layer.functions_pilatus.frame_id","text":"Gets a unique identifier for a Pilatus detector data frame. This function returns a label that unambiguously identifies, within an event, the frame currently being processed. Each Pilatus event only contains one frame, therefore this function always returns the string \"0\". Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique frame identifier (within an event).","title":"frame_id()"},{"location":"reference/om/data_retrieval_layer/functions_pilatus/#om.data_retrieval_layer.functions_pilatus.timestamp","text":"Gets the timestamp of a Pilatus data event. For the Pilatus detector, each HiDRA or file event corresponds to a single CBF data file: the creation time of the file, retrieved from the filesystem or HiDRA, is used as a timestamp for the event. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float64 The timestamp of the event in seconds from the Epoch.","title":"timestamp()"},{"location":"reference/om/data_retrieval_layer/functions_psana/","text":"functions_psana Retrieval of data from the psana framework. This module contains functions that retrieve data from the psana software framework (used at the LCLS facility) using the psana Detector interface. It also contains functions that initialize the Detector interface itself. beam_energy ( event ) Gets the beam energy for an event retrieved from psana at LCLS. At LCLS, detector beam energy information is retrieved from an Epics variable. This function retrieves the information from the Epics variable identified by the 'psana_detector_distance_epics_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The energy of the beam in eV. beam_energy_init ( monitor_parameters ) Initializes the psana Detector interface for beam energy data at LCLS. This function initializes the beam energy Detector interface, preparing it to retrieve energy information provided by LCLS' accelerator diagnostics. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data. detector_data_init ( monitor_parameters ) Initializes the psana Detector interface for x-ray detector data at LCLS. This function initializes the Detector interface for the detector identified by the 'psana_detector_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data. detector_distance ( event ) Gets the detector distance for an event retrieved from psana at LCLS. At LCLS, detector distance information is retrieved from an Epics variable. This function retrieves the information from the Epics variable identified by the 'psana_detector_distance_epics_name' entry in the 'data_retrieval_ayer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The distance between the detector and the sample in mm. detector_distance_init ( monitor_parameters ) Initializes the psana Detector interface for detector distance data at LCLS. At LCLS, detector distance information is recovered from an Epics variable which reports the position of a stage. This function initializes the relevant Detector interface using the Epics variable identified by the 'psana_detector_distance_epics_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data. digitizer_data ( event ) Get digitizer data for an event retrieved from psana at LCLS. This function retrieves data from the digitizer identified by the 'psana_digitizer_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray The waveform from the digitizer. digitizer_data_init ( monitor_parameters ) Initializes the psana Detector interface for digitizer data at LCLS. This function initializes the Detector interface for the digitizer identified by the 'psana_digitizer_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data. event_id ( event ) Gets a unique identifier for an event retrieved from a Pilatus detector. This function returns a label that unambiguously identifies, within an experiment, the event currently being processed. For the LCLS facility, three numbers are needed to unambigously identify an event: the portion of the event timestamp that corresponds to seconds, the portion of the timestamp that corresponds to nanoseconds, and a fiducial number. The event label at LCLS is a string which unifies these three numbers separating them with dashes. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique event identifier. event_id_init ( monitor_parameters ) Initializes the psana Detector interface for the event identifier at LCLS. This function initializes the event identifier Detector interface, preparing it to retrieve a label that unambiguosly identifies the event being processed. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required frame_id ( event ) Gets a unique identifier for a Pilatus detector data frame. This function returns a label that unambiguously identifies, within an event, the frame currently being processed. Each psana event only contains one detector frame, therefore this function always returns the string \"0\". Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique frame identifier (within an event). frame_id_init ( monitor_parameters ) Initializes the psana Detector interface for the frame identifier at LCLS. This function initializes the frame identifier Detector interface, preparing it to retrieve a label that unambiguosly identifies, within the current event, the frame being processed. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required opal_data ( event ) Gets Opal camera data for an event retrieved from psana at LCLS. This function retrieves data from the Opal camera identified by the 'psana_opal_name' entry in the 'data_retrieval_layer' parameter group of the configuration file . Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray A 2D array containing the image from the Opal camera. opal_data_init ( monitor_parameters ) Initializes the psana Detector interface for Opal camera data at LCLS. This function initialize the Detector interface for the Opal camera identified by the 'psana_opal_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data. optical_laser_active ( event ) Gets the status of an optical laser for an event retrieved from psana at LCLS. At LCLS, the status of an optical laser is determined by monitoring an EVR event. This function determines the status of the optical laser by checking if the EVR source provides a specific event code for the current frame. The name of the event source must be specified in the 'psana_evr_source_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. The EVR event code that signals an active optical laser must be provided in the 'psana_evr_code_for_active_optical_laser' entry in the same parameter group. If the source shows this EVR code for the current frame, the optical laser is considered active. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description bool True if the optical laser is active for the current frame. False otherwise. optical_laser_active_init ( monitor_parameters ) Initializes the psana Detector interface for an optical laser at LCLS. At LCLS, the status of an optical laser is determined by monitoring an EVR event source. This function initializes the Detector interface for the EVR event source identified by the 'psana_evr_source_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data. timestamp ( event ) Gets the timestamp of an event retrieved from psana at LCLS. At LCLS, the time stamp of a data event is provided by the LCLS timing system. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float64 The timestamp of the event in seconds from the Epoch. timestamp_init ( monitor_parameters ) Initializes the psana Detector interface for timestamp data at LCLS. This function initializes the timestamp Detector interface, preparing it to retrieve timing information provided by the LCLS timing system. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required timetool_data ( event ) Gets timetool data for an event retrieved from psana at LCLS. At LCLS, timetool data is recovered from an Epics variable. This function retrieves the information from the Epics variable identified by the 'psana_timetools_epics_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The readout of the timetool instrument. timetool_data_init ( monitor_parameters ) Initializes the psana Detector interface for timetool data at LCLS. At LCLS, timetool data is recovered from an Epics variable. This function initializes the timetool Detector interface using the Epics variable identified by the 'psana_timetools_epics_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data. xrays_active ( event ) Initializes the psana Detector interface for the x-ray beam status at LCLS. At LCLS, the status of the x-ray beam is determined by monitoring an EVR event source. This function determines the status of the x-ray beam by checking if the EVR source provides a specific event code for the current frame. The name of the event source must be specified in the 'psana_evr_source_name' entry of the 'data_retrieval_layer' parameter group of the configuration file. The EVR event code that signals an active x-ray beam must be provided in the 'psana_evr_code_for_active_xray_beam\" entry in the same parameter group. If the source shows this EVR code for the current frame, the x-ray beam is considered active. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description bool True if the x-ray beam is active for the current frame. False otherwise. xrays_active_init ( monitor_parameters ) Initializes the psana Detector interface for the x-ray beam status at LCLS. At LCLS, the status of the x-ray beam is determined by monitoring an EVR event source. This function initializes the Detector interface for the EVR event source identified by the 'psana_evr_source_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"functions_psana"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana","text":"Retrieval of data from the psana framework. This module contains functions that retrieve data from the psana software framework (used at the LCLS facility) using the psana Detector interface. It also contains functions that initialize the Detector interface itself.","title":"functions_psana"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.beam_energy","text":"Gets the beam energy for an event retrieved from psana at LCLS. At LCLS, detector beam energy information is retrieved from an Epics variable. This function retrieves the information from the Epics variable identified by the 'psana_detector_distance_epics_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The energy of the beam in eV.","title":"beam_energy()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.beam_energy_init","text":"Initializes the psana Detector interface for beam energy data at LCLS. This function initializes the beam energy Detector interface, preparing it to retrieve energy information provided by LCLS' accelerator diagnostics. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"beam_energy_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.detector_data_init","text":"Initializes the psana Detector interface for x-ray detector data at LCLS. This function initializes the Detector interface for the detector identified by the 'psana_detector_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"detector_data_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.detector_distance","text":"Gets the detector distance for an event retrieved from psana at LCLS. At LCLS, detector distance information is retrieved from an Epics variable. This function retrieves the information from the Epics variable identified by the 'psana_detector_distance_epics_name' entry in the 'data_retrieval_ayer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The distance between the detector and the sample in mm.","title":"detector_distance()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.detector_distance_init","text":"Initializes the psana Detector interface for detector distance data at LCLS. At LCLS, detector distance information is recovered from an Epics variable which reports the position of a stage. This function initializes the relevant Detector interface using the Epics variable identified by the 'psana_detector_distance_epics_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"detector_distance_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.digitizer_data","text":"Get digitizer data for an event retrieved from psana at LCLS. This function retrieves data from the digitizer identified by the 'psana_digitizer_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray The waveform from the digitizer.","title":"digitizer_data()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.digitizer_data_init","text":"Initializes the psana Detector interface for digitizer data at LCLS. This function initializes the Detector interface for the digitizer identified by the 'psana_digitizer_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"digitizer_data_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.event_id","text":"Gets a unique identifier for an event retrieved from a Pilatus detector. This function returns a label that unambiguously identifies, within an experiment, the event currently being processed. For the LCLS facility, three numbers are needed to unambigously identify an event: the portion of the event timestamp that corresponds to seconds, the portion of the timestamp that corresponds to nanoseconds, and a fiducial number. The event label at LCLS is a string which unifies these three numbers separating them with dashes. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique event identifier.","title":"event_id()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.event_id_init","text":"Initializes the psana Detector interface for the event identifier at LCLS. This function initializes the event identifier Detector interface, preparing it to retrieve a label that unambiguosly identifies the event being processed. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required","title":"event_id_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.frame_id","text":"Gets a unique identifier for a Pilatus detector data frame. This function returns a label that unambiguously identifies, within an event, the frame currently being processed. Each psana event only contains one detector frame, therefore this function always returns the string \"0\". Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description str A unique frame identifier (within an event).","title":"frame_id()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.frame_id_init","text":"Initializes the psana Detector interface for the frame identifier at LCLS. This function initializes the frame identifier Detector interface, preparing it to retrieve a label that unambiguosly identifies, within the current event, the frame being processed. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required","title":"frame_id_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.opal_data","text":"Gets Opal camera data for an event retrieved from psana at LCLS. This function retrieves data from the Opal camera identified by the 'psana_opal_name' entry in the 'data_retrieval_layer' parameter group of the configuration file . Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray A 2D array containing the image from the Opal camera.","title":"opal_data()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.opal_data_init","text":"Initializes the psana Detector interface for Opal camera data at LCLS. This function initialize the Detector interface for the Opal camera identified by the 'psana_opal_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"opal_data_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.optical_laser_active","text":"Gets the status of an optical laser for an event retrieved from psana at LCLS. At LCLS, the status of an optical laser is determined by monitoring an EVR event. This function determines the status of the optical laser by checking if the EVR source provides a specific event code for the current frame. The name of the event source must be specified in the 'psana_evr_source_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. The EVR event code that signals an active optical laser must be provided in the 'psana_evr_code_for_active_optical_laser' entry in the same parameter group. If the source shows this EVR code for the current frame, the optical laser is considered active. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description bool True if the optical laser is active for the current frame. False otherwise.","title":"optical_laser_active()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.optical_laser_active_init","text":"Initializes the psana Detector interface for an optical laser at LCLS. At LCLS, the status of an optical laser is determined by monitoring an EVR event source. This function initializes the Detector interface for the EVR event source identified by the 'psana_evr_source_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"optical_laser_active_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.timestamp","text":"Gets the timestamp of an event retrieved from psana at LCLS. At LCLS, the time stamp of a data event is provided by the LCLS timing system. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float64 The timestamp of the event in seconds from the Epoch.","title":"timestamp()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.timestamp_init","text":"Initializes the psana Detector interface for timestamp data at LCLS. This function initializes the timestamp Detector interface, preparing it to retrieve timing information provided by the LCLS timing system. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required","title":"timestamp_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.timetool_data","text":"Gets timetool data for an event retrieved from psana at LCLS. At LCLS, timetool data is recovered from an Epics variable. This function retrieves the information from the Epics variable identified by the 'psana_timetools_epics_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description float The readout of the timetool instrument.","title":"timetool_data()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.timetool_data_init","text":"Initializes the psana Detector interface for timetool data at LCLS. At LCLS, timetool data is recovered from an Epics variable. This function initializes the timetool Detector interface using the Epics variable identified by the 'psana_timetools_epics_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"timetool_data_init()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.xrays_active","text":"Initializes the psana Detector interface for the x-ray beam status at LCLS. At LCLS, the status of the x-ray beam is determined by monitoring an EVR event source. This function determines the status of the x-ray beam by checking if the EVR source provides a specific event code for the current frame. The name of the event source must be specified in the 'psana_evr_source_name' entry of the 'data_retrieval_layer' parameter group of the configuration file. The EVR event code that signals an active x-ray beam must be provided in the 'psana_evr_code_for_active_xray_beam\" entry in the same parameter group. If the source shows this EVR code for the current frame, the x-ray beam is considered active. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description bool True if the x-ray beam is active for the current frame. False otherwise.","title":"xrays_active()"},{"location":"reference/om/data_retrieval_layer/functions_psana/#om.data_retrieval_layer.functions_psana.xrays_active_init","text":"Initializes the psana Detector interface for the x-ray beam status at LCLS. At LCLS, the status of the x-ray beam is determined by monitoring an EVR event source. This function initializes the Detector interface for the EVR event source identified by the 'psana_evr_source_name' entry in the 'data_retrieval_layer' parameter group of the configuration file. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required Returns: Type Description Any A psana object that can be used later to retrieve the data.","title":"xrays_active_init()"},{"location":"reference/om/data_retrieval_layer/functions_rayonix/","text":"functions_rayonix Retrieval of Rayonix detector data from psana. This module contains functions that retrieve Rayonix detector data from the psana software framework (used at the LCLS facility). detector_data ( event ) Retrieves one Rayonix 4M detector data frame from psana. This function retrieves a single Rayonix detector frame from psana. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"functions_rayonix"},{"location":"reference/om/data_retrieval_layer/functions_rayonix/#om.data_retrieval_layer.functions_rayonix","text":"Retrieval of Rayonix detector data from psana. This module contains functions that retrieve Rayonix detector data from the psana software framework (used at the LCLS facility).","title":"functions_rayonix"},{"location":"reference/om/data_retrieval_layer/functions_rayonix/#om.data_retrieval_layer.functions_rayonix.detector_data","text":"Retrieves one Rayonix 4M detector data frame from psana. This function retrieves a single Rayonix detector frame from psana. It returns the frame as a 2D array storing pixel data. Parameters: Name Type Description Default event Dict[str, Any] A dictionary storing the event data. required Returns: Type Description ndarray One frame of detector data.","title":"detector_data()"},{"location":"reference/om/graphical_interfaces/","text":"graphical_interfaces special OM's graphical user interfaces. This package contains OM's Qt-based graphical user interfaces for the desktop. One module is dedicated to each GUI or viewer. base crystallography_frame_viewer crystallography_gui crystallography_parameter_tweaker","title":"__init__"},{"location":"reference/om/graphical_interfaces/#om.graphical_interfaces","text":"OM's graphical user interfaces. This package contains OM's Qt-based graphical user interfaces for the desktop. One module is dedicated to each GUI or viewer. base crystallography_frame_viewer crystallography_gui crystallography_parameter_tweaker","title":"graphical_interfaces"},{"location":"reference/om/graphical_interfaces/base/","text":"base Base abstract classes for OM's graphical interfaces. This module contains base abstract classes for OM's graphical user interfaces and viewers. OmGui See documentation of the __init__ function. Base class: QtWidgets.QMainWindow Metaclass: QtMetaclass __init__ ( self , url , tag ) special Base class for OM's graphical user interfaces. This class implements the common elements of all OM's graphical interfaces. It should be subclassed to implement specific interfaces and viewers. The constructor of this class instantiates a listening thread that receives (filtered) data from the broadcasting socket of an OnDA Monitor. It also sets up the basic widget structure of the GUI. Finally, it makes sure that the GUI update function is called at regular intervals to update the relevant GUI elements. Derived classes should always call the constructor of this class to perform the GUI initialization. Furthermore, please notice that the update_gui method of this class is abstract: each derived graphical interface is supposed to provide its own implementation to update its own specific widgets and plots. Parameters: Name Type Description Default url str the URL at which the GUI will connect and listen for data. This must be a string in the format used by the ZeroMQ Protocol. required tag str a string used to filter the data received from OM. Only data whose tag label matches this argument will be accepted and received. required Attributes: Name Type Description received_data List[Dict[bytes, Any]] The latest data received from Om. A list of aggregated event data entries, each stored in a dictionary. is_gui_listening bool The state of the listening thread. True if the GUI is currently listening to OM, False otherwise. start_listening ( self ) Connects to an OM monitor and starts listening for broadcasted data. This function instructs the listening thread to connect to an OM socket and start listening for data. stop_listening ( self ) Disconnects from an OM monitor and stops listening for data. This function instructs the listening thread to disconnect from the OM socket and to stop receiveing data. update_gui ( self ) Updates GUI elements. This is an abstract method. This function is called at regular intervals and updates the elements of the GUI as required. QtMetaclass Metaclass for ABC classes with Qt inheritance. Base class: type(QtCore.QObject) , ABCMeta This metaclass is used internally to resolve an issue with classes that inherit from Qt and non-Qt classes at the same time.","title":"base"},{"location":"reference/om/graphical_interfaces/base/#om.graphical_interfaces.base","text":"Base abstract classes for OM's graphical interfaces. This module contains base abstract classes for OM's graphical user interfaces and viewers.","title":"base"},{"location":"reference/om/graphical_interfaces/base/#om.graphical_interfaces.base.OmGui","text":"See documentation of the __init__ function. Base class: QtWidgets.QMainWindow Metaclass: QtMetaclass","title":"OmGui"},{"location":"reference/om/graphical_interfaces/base/#om.graphical_interfaces.base.OmGui.__init__","text":"Base class for OM's graphical user interfaces. This class implements the common elements of all OM's graphical interfaces. It should be subclassed to implement specific interfaces and viewers. The constructor of this class instantiates a listening thread that receives (filtered) data from the broadcasting socket of an OnDA Monitor. It also sets up the basic widget structure of the GUI. Finally, it makes sure that the GUI update function is called at regular intervals to update the relevant GUI elements. Derived classes should always call the constructor of this class to perform the GUI initialization. Furthermore, please notice that the update_gui method of this class is abstract: each derived graphical interface is supposed to provide its own implementation to update its own specific widgets and plots. Parameters: Name Type Description Default url str the URL at which the GUI will connect and listen for data. This must be a string in the format used by the ZeroMQ Protocol. required tag str a string used to filter the data received from OM. Only data whose tag label matches this argument will be accepted and received. required Attributes: Name Type Description received_data List[Dict[bytes, Any]] The latest data received from Om. A list of aggregated event data entries, each stored in a dictionary. is_gui_listening bool The state of the listening thread. True if the GUI is currently listening to OM, False otherwise.","title":"__init__()"},{"location":"reference/om/graphical_interfaces/base/#om.graphical_interfaces.base.OmGui.start_listening","text":"Connects to an OM monitor and starts listening for broadcasted data. This function instructs the listening thread to connect to an OM socket and start listening for data.","title":"start_listening()"},{"location":"reference/om/graphical_interfaces/base/#om.graphical_interfaces.base.OmGui.stop_listening","text":"Disconnects from an OM monitor and stops listening for data. This function instructs the listening thread to disconnect from the OM socket and to stop receiveing data.","title":"stop_listening()"},{"location":"reference/om/graphical_interfaces/base/#om.graphical_interfaces.base.OmGui.update_gui","text":"Updates GUI elements. This is an abstract method. This function is called at regular intervals and updates the elements of the GUI as required.","title":"update_gui()"},{"location":"reference/om/graphical_interfaces/base/#om.graphical_interfaces.base.QtMetaclass","text":"Metaclass for ABC classes with Qt inheritance. Base class: type(QtCore.QObject) , ABCMeta This metaclass is used internally to resolve an issue with classes that inherit from Qt and non-Qt classes at the same time.","title":"QtMetaclass"},{"location":"reference/om/graphical_interfaces/crystallography_frame_viewer/","text":"crystallography_frame_viewer OM's Frame Viewer for Crystallography. This module contains the implementation of a graphical interface that displays detector data frames in crystallography experiments. CrystallographyFrameViewer See documentation of the __init__ function. Base class: OmGui __init__ ( self , url ) special OM frame viewer for crystallography. This class implements a frame viewer for crystallography experiments. It is a subclass of the OmGui base class. The viewer receives detector frame data from an OnDA Monitor for Crystallography when it is tagged with the 'omdetectordata' label. The received data must include processed detector frames, together with information on any Bragg peak detected in them. The viewer displays the frames and the position of the detected peaks. A data buffer allows the viewer to stop receiving data from the monitor but still keep in memory the last 10 displayed frames for inspection. Parameters: Name Type Description Default url str the URL at which the GUI will connect and listen for data. This must be a string in the format used by the ZeroMQ Protocol. required update_gui ( self ) Updates the elements of the Crystallography Frame Viewer. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function stores the data received from OM, and calls the internal functions that update the displayed detector frame and the detected peaks. crystallography_frame_viewer.py OM Frame Viewer for Crystallography. This program must connect to a running OnDA Monitor for Crystallography. If the monitor broadcasts detector frame data, this viewer will display it. The viewer will also show, overlayed on the frame data, any detected Bragg peak. The data stream from the monitor can also be temporarily paused, and any of 10 most recently displayed detector frames can be recalled for inspection. The viewer connects to and OnDA Monitor running at the IP address (or hostname) specified by the URL string. This is a string in the format used by the ZeroMQ Protocol. The URL string is optional. If not provided, it defaults to \"tcp://127.0.0.1:12321\" and the viewer connects, using the tcp protocol, to a monitor running on the local machine at port 12321. Usage: crystallography_frame_viewer.py [OPTIONS] [URL] Options: --help Show this message and exit.","title":"crystallography_frame_viewer"},{"location":"reference/om/graphical_interfaces/crystallography_frame_viewer/#om.graphical_interfaces.crystallography_frame_viewer","text":"OM's Frame Viewer for Crystallography. This module contains the implementation of a graphical interface that displays detector data frames in crystallography experiments.","title":"crystallography_frame_viewer"},{"location":"reference/om/graphical_interfaces/crystallography_frame_viewer/#om.graphical_interfaces.crystallography_frame_viewer.CrystallographyFrameViewer","text":"See documentation of the __init__ function. Base class: OmGui","title":"CrystallographyFrameViewer"},{"location":"reference/om/graphical_interfaces/crystallography_frame_viewer/#om.graphical_interfaces.crystallography_frame_viewer.CrystallographyFrameViewer.__init__","text":"OM frame viewer for crystallography. This class implements a frame viewer for crystallography experiments. It is a subclass of the OmGui base class. The viewer receives detector frame data from an OnDA Monitor for Crystallography when it is tagged with the 'omdetectordata' label. The received data must include processed detector frames, together with information on any Bragg peak detected in them. The viewer displays the frames and the position of the detected peaks. A data buffer allows the viewer to stop receiving data from the monitor but still keep in memory the last 10 displayed frames for inspection. Parameters: Name Type Description Default url str the URL at which the GUI will connect and listen for data. This must be a string in the format used by the ZeroMQ Protocol. required","title":"__init__()"},{"location":"reference/om/graphical_interfaces/crystallography_frame_viewer/#om.graphical_interfaces.crystallography_frame_viewer.CrystallographyFrameViewer.update_gui","text":"Updates the elements of the Crystallography Frame Viewer. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function stores the data received from OM, and calls the internal functions that update the displayed detector frame and the detected peaks.","title":"update_gui()"},{"location":"reference/om/graphical_interfaces/crystallography_frame_viewer/#crystallography_frame_viewerpy","text":"OM Frame Viewer for Crystallography. This program must connect to a running OnDA Monitor for Crystallography. If the monitor broadcasts detector frame data, this viewer will display it. The viewer will also show, overlayed on the frame data, any detected Bragg peak. The data stream from the monitor can also be temporarily paused, and any of 10 most recently displayed detector frames can be recalled for inspection. The viewer connects to and OnDA Monitor running at the IP address (or hostname) specified by the URL string. This is a string in the format used by the ZeroMQ Protocol. The URL string is optional. If not provided, it defaults to \"tcp://127.0.0.1:12321\" and the viewer connects, using the tcp protocol, to a monitor running on the local machine at port 12321. Usage: crystallography_frame_viewer.py [OPTIONS] [URL] Options: --help Show this message and exit.","title":"crystallography_frame_viewer.py"},{"location":"reference/om/graphical_interfaces/crystallography_gui/","text":"crystallography_gui OM's GUI for Crystallography. This module contains the implementation of a graphical interface that displays reduced and aggregated data in crystallography experiments. CrystallographyGui See documentation of the __init__ function. Base class: OmGui __init__ ( self , url ) special OM graphical user interface for crystallography. This class implements a graphical user interface for crystallography experiments. It is a subclass of the OmGui base class. This GUI receives reduced and aggregated data from an OnDA Monitor for Crystallography when it is tagged with the 'omdata' label. The data must contain information about peaks detected in the frames recently processed by the monitor and information about the current hit rate. The GUI displays a plot showing the evolution of the hit rate over time, plus a virtual powder pattern created using the detected peaks. Parameters: Name Type Description Default url str the URL at which the GUI will connect and listen for data. This must be a string in the format used by the ZeroMQ Protocol. required update_gui ( self ) Updates the elements of the Crystallography GUI. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function stores the data received from OM, and calls the internal functions that update the hit rate history plot and the virtual power pattern. crystallography_gui.py OM Graphical User Interface for Crystallography. This program must connect to a running OnDA Monitor for Crystallography. If the monitor broadcasts the necessary information, this GUI will display the evolution of the hit rate over time, plus a real-time virtual powder pattern created using the peaks detected in detector frames processed by the monitor. The GUI connects to and OnDA Monitor running at the IP address (or hostname) specified by the URL string. This is a string in the format used by the ZeroMQ Protocol. The URL string is optional. If not provided, it defaults to \"tcp://127.0.0.1:12321\" and the viewer connects, using the tcp protocol, to a monitor running on the local machine at port 12321. Usage: crystallography_gui.py [OPTIONS] [URL] Options: --help Show this message and exit.","title":"crystallography_gui"},{"location":"reference/om/graphical_interfaces/crystallography_gui/#om.graphical_interfaces.crystallography_gui","text":"OM's GUI for Crystallography. This module contains the implementation of a graphical interface that displays reduced and aggregated data in crystallography experiments.","title":"crystallography_gui"},{"location":"reference/om/graphical_interfaces/crystallography_gui/#om.graphical_interfaces.crystallography_gui.CrystallographyGui","text":"See documentation of the __init__ function. Base class: OmGui","title":"CrystallographyGui"},{"location":"reference/om/graphical_interfaces/crystallography_gui/#om.graphical_interfaces.crystallography_gui.CrystallographyGui.__init__","text":"OM graphical user interface for crystallography. This class implements a graphical user interface for crystallography experiments. It is a subclass of the OmGui base class. This GUI receives reduced and aggregated data from an OnDA Monitor for Crystallography when it is tagged with the 'omdata' label. The data must contain information about peaks detected in the frames recently processed by the monitor and information about the current hit rate. The GUI displays a plot showing the evolution of the hit rate over time, plus a virtual powder pattern created using the detected peaks. Parameters: Name Type Description Default url str the URL at which the GUI will connect and listen for data. This must be a string in the format used by the ZeroMQ Protocol. required","title":"__init__()"},{"location":"reference/om/graphical_interfaces/crystallography_gui/#om.graphical_interfaces.crystallography_gui.CrystallographyGui.update_gui","text":"Updates the elements of the Crystallography GUI. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function stores the data received from OM, and calls the internal functions that update the hit rate history plot and the virtual power pattern.","title":"update_gui()"},{"location":"reference/om/graphical_interfaces/crystallography_gui/#crystallography_guipy","text":"OM Graphical User Interface for Crystallography. This program must connect to a running OnDA Monitor for Crystallography. If the monitor broadcasts the necessary information, this GUI will display the evolution of the hit rate over time, plus a real-time virtual powder pattern created using the peaks detected in detector frames processed by the monitor. The GUI connects to and OnDA Monitor running at the IP address (or hostname) specified by the URL string. This is a string in the format used by the ZeroMQ Protocol. The URL string is optional. If not provided, it defaults to \"tcp://127.0.0.1:12321\" and the viewer connects, using the tcp protocol, to a monitor running on the local machine at port 12321. Usage: crystallography_gui.py [OPTIONS] [URL] Options: --help Show this message and exit.","title":"crystallography_gui.py"},{"location":"reference/om/graphical_interfaces/crystallography_parameter_tweaker/","text":"crystallography_parameter_tweaker OM's real-time Parameter Tweaker. This module contains the implementation of a graphical interface that can be used in crystallography experiments to test peak-finding parameters in real time. CrystallographyParameterTweaker See documentation of the __init__ function. Base class: OmGui __init__ ( self , url , monitor_parameters ) special OM Parameter Tweaker for Crystallography. This class implements a graphical user interface that can be used to test new peak finding parameters in real time. It is a subclass of the OmGui base class. This GUI receives detector frame data from an OndA Monitor for Crystallography when it is tagged with the 'omdetectordata' label. The received data must include processed detector frames. The GUI allows the user to choose a set of peak-finding parameters. It then applies the Peakfinder8PeakDetection algorithm on the fly to each received frame. FInally, it displays the frame together with the detected peaks. A data buffer allows the GUI to stop receiving data from the monitor but still keep in memory the last 10 received frames to inspect and operate on. Parameters: Name Type Description Default url str the URL at which the GUI will connect and listen for data. This must be a string in the format used by the ZeroMQ Protocol. required update_gui ( self ) Updates the elements of the Crystallography Parameter Tweaker. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function stores the data received from OM, and calls the internal functions that initially perform the hit finding with the current chosen parameters, and then display the detector frame and the detected peaks. crystallography_parameter_tweaker.py OM Parameter Tweaker for Crystallography. This program must connect to a running OnDA Monitor for Crystallography. If the monitor broadcasts detector frame data, this graphical interface will receive it. The user will be allowed to choose a set of peakfinding parameters which will then be applied to each received detector frame. Each frame will be displayed with its detected peaks. The data stream from the monitor can also be temporarily paused, and any of the last 10 displayed detector frames can be recalled and operated on. The purpose of this GUI is to allow the user to refine the peak finding parameters without interfering with with the OnDA Monitor observing the experiment. The GUI conects to and OnDA Monitor running at the IP address (or hostname) specified by the URL string. This is a string in the format used by the ZeroMQ Protocol. The URL string is optional. If not provided, URL defaults to tcp://127.0.0.1:12321 and the GUI connects, using the tcp protocol, to a monitor running on the local machine at port 12321. Usage: crystallography_parameter_tweaker.py [OPTIONS] [URL] Options: -c, --config PATH configuration file (default: monitor.yaml file in the current working directory --help Show this message and exit.","title":"crystallography_parameter_tweaker"},{"location":"reference/om/graphical_interfaces/crystallography_parameter_tweaker/#om.graphical_interfaces.crystallography_parameter_tweaker","text":"OM's real-time Parameter Tweaker. This module contains the implementation of a graphical interface that can be used in crystallography experiments to test peak-finding parameters in real time.","title":"crystallography_parameter_tweaker"},{"location":"reference/om/graphical_interfaces/crystallography_parameter_tweaker/#om.graphical_interfaces.crystallography_parameter_tweaker.CrystallographyParameterTweaker","text":"See documentation of the __init__ function. Base class: OmGui","title":"CrystallographyParameterTweaker"},{"location":"reference/om/graphical_interfaces/crystallography_parameter_tweaker/#om.graphical_interfaces.crystallography_parameter_tweaker.CrystallographyParameterTweaker.__init__","text":"OM Parameter Tweaker for Crystallography. This class implements a graphical user interface that can be used to test new peak finding parameters in real time. It is a subclass of the OmGui base class. This GUI receives detector frame data from an OndA Monitor for Crystallography when it is tagged with the 'omdetectordata' label. The received data must include processed detector frames. The GUI allows the user to choose a set of peak-finding parameters. It then applies the Peakfinder8PeakDetection algorithm on the fly to each received frame. FInally, it displays the frame together with the detected peaks. A data buffer allows the GUI to stop receiving data from the monitor but still keep in memory the last 10 received frames to inspect and operate on. Parameters: Name Type Description Default url str the URL at which the GUI will connect and listen for data. This must be a string in the format used by the ZeroMQ Protocol. required","title":"__init__()"},{"location":"reference/om/graphical_interfaces/crystallography_parameter_tweaker/#om.graphical_interfaces.crystallography_parameter_tweaker.CrystallographyParameterTweaker.update_gui","text":"Updates the elements of the Crystallography Parameter Tweaker. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function stores the data received from OM, and calls the internal functions that initially perform the hit finding with the current chosen parameters, and then display the detector frame and the detected peaks.","title":"update_gui()"},{"location":"reference/om/graphical_interfaces/crystallography_parameter_tweaker/#crystallography_parameter_tweakerpy","text":"OM Parameter Tweaker for Crystallography. This program must connect to a running OnDA Monitor for Crystallography. If the monitor broadcasts detector frame data, this graphical interface will receive it. The user will be allowed to choose a set of peakfinding parameters which will then be applied to each received detector frame. Each frame will be displayed with its detected peaks. The data stream from the monitor can also be temporarily paused, and any of the last 10 displayed detector frames can be recalled and operated on. The purpose of this GUI is to allow the user to refine the peak finding parameters without interfering with with the OnDA Monitor observing the experiment. The GUI conects to and OnDA Monitor running at the IP address (or hostname) specified by the URL string. This is a string in the format used by the ZeroMQ Protocol. The URL string is optional. If not provided, URL defaults to tcp://127.0.0.1:12321 and the GUI connects, using the tcp protocol, to a monitor running on the local machine at port 12321. Usage: crystallography_parameter_tweaker.py [OPTIONS] [URL] Options: -c, --config PATH configuration file (default: monitor.yaml file in the current working directory --help Show this message and exit.","title":"crystallography_parameter_tweaker.py"},{"location":"reference/om/lib/","text":"lib special OM's C/C++ extensions. This package contains OM's C/C++-language extensions. Each module in this package is an extension compiled into a dynamic libray together with its Cython wrapper. peakfinder8_extension","title":"__init__"},{"location":"reference/om/lib/#om.lib","text":"OM's C/C++ extensions. This package contains OM's C/C++-language extensions. Each module in this package is an extension compiled into a dynamic libray together with its Cython wrapper. peakfinder8_extension","title":"lib"},{"location":"reference/om/lib/peakfinder8_extension/","text":"Peakfinder8 extension. This extension contains an implementation of Cheetah's 'peakfinder8' peak detection algorithm. peakfinder_8 ( max_num_peaks , data , mask , pix_r , asic_nx , asic_ny , nasics_x , nasics_y , adc_thresh , hitfinder_min_snr , hitfinder_min_pix_count , hitfinder_max_pix_count , hitfinder_local_bg_radius ) Peakfinder8 peak detection. This function finds peaks in a detector data frame using the 'peakfinder8' strategy from the Cheetah software package. The 'peakfinder8' peak detection strategy is described in the following publication: A. Barty, R. A. Kirian, F. R. N. C. Maia, M. Hantke, C. H. Yoon, T. A. White, and H. N. Chapman, \"Cheetah: software for high-throughput reduction and analysis of serial femtosecond x-ray diffraction data\", J Appl Crystallogr, vol. 47, pp. 1118-1131 (2014). Parameters: Name Type Description Default max_num_peaks int The maximum number of peaks that will be retrieved from each data frame. Additional peaks will be ignored. required data ndarray The detector data frame on which the peak finding must be performed (as an numpy array of float32). required mask ndarray A numpy array of int8 storing a mask. The map can be used to mark areas of the data frame that must be excluded from the peak search. The map must be a numpy array of the same shape as the data frame on which the algorithm will be applied. Each pixel in the map must have a value of either 0, meaning that the corresponding pixel in the data frame should be ignored, or 1, meaning that the corresponding pixel should be included in the search. The map is only used to exclude areas from the peak search: the data is not modified in any way. required pix_r ndarray A numpy array of float32 with radius information. The array must have the same shape as the data frame on which the algorithm will be applied. Each element of the array must store, for the corresponding pixel in the data frame, the distance in pixels from the origin of the detector reference system (usually the center of the detector). required asic_nx int The fs size in pixels of each detector panel in the data frame. required asic_ny int The ss size in pixels of each detector panel in the data frame. required nasics_x int The number of panels along the fs axis of the data frame. required nasics_y int The number of panels along the ss axis of the data frame. required adc_thresh float The minimum ADC threshold for peak detection. required hitfinder_min_snr float The minimum signal-to-noise ratio for peak detection. required hitfinder_min_pix_count int The minimum size of a peak in pixels. required hitfinder_max_pix_count int The maximum size of a peak in pixels. required hitfinder_local_bg_radius int The radius for the estimation of the local background in pixels. required Returns: Type Description Tuple[int, List[float], List[float], List[float], List[float], List[float], List[float]] A tuple storing information about the detected peaks. The tuple has the following elements: The first entry stores the number of peaks that were detected in the data frame. The second entry is a list storing the fractional fs indexes that locate the detected peaks in the data frame. The third entry is a list storing the fractional ss indexes that locate the the detected peaks in the data frame. The fourth entry is a list storing the integrated intensities for the detected peaks. The fifth entry is a list storing the number of pixels that make up each detected peak. The sixth entry is a list storing, for each peak, the value of the pixel with the maximum intensity. The seventh entry is a list storing the signal-to-noise ratio of each detected peak.","title":"peakfinder8_extension"},{"location":"reference/om/lib/peakfinder8_extension/#om.lib.peakfinder8_extension_stub.peakfinder_8","text":"Peakfinder8 peak detection. This function finds peaks in a detector data frame using the 'peakfinder8' strategy from the Cheetah software package. The 'peakfinder8' peak detection strategy is described in the following publication: A. Barty, R. A. Kirian, F. R. N. C. Maia, M. Hantke, C. H. Yoon, T. A. White, and H. N. Chapman, \"Cheetah: software for high-throughput reduction and analysis of serial femtosecond x-ray diffraction data\", J Appl Crystallogr, vol. 47, pp. 1118-1131 (2014). Parameters: Name Type Description Default max_num_peaks int The maximum number of peaks that will be retrieved from each data frame. Additional peaks will be ignored. required data ndarray The detector data frame on which the peak finding must be performed (as an numpy array of float32). required mask ndarray A numpy array of int8 storing a mask. The map can be used to mark areas of the data frame that must be excluded from the peak search. The map must be a numpy array of the same shape as the data frame on which the algorithm will be applied. Each pixel in the map must have a value of either 0, meaning that the corresponding pixel in the data frame should be ignored, or 1, meaning that the corresponding pixel should be included in the search. The map is only used to exclude areas from the peak search: the data is not modified in any way. required pix_r ndarray A numpy array of float32 with radius information. The array must have the same shape as the data frame on which the algorithm will be applied. Each element of the array must store, for the corresponding pixel in the data frame, the distance in pixels from the origin of the detector reference system (usually the center of the detector). required asic_nx int The fs size in pixels of each detector panel in the data frame. required asic_ny int The ss size in pixels of each detector panel in the data frame. required nasics_x int The number of panels along the fs axis of the data frame. required nasics_y int The number of panels along the ss axis of the data frame. required adc_thresh float The minimum ADC threshold for peak detection. required hitfinder_min_snr float The minimum signal-to-noise ratio for peak detection. required hitfinder_min_pix_count int The minimum size of a peak in pixels. required hitfinder_max_pix_count int The maximum size of a peak in pixels. required hitfinder_local_bg_radius int The radius for the estimation of the local background in pixels. required Returns: Type Description Tuple[int, List[float], List[float], List[float], List[float], List[float], List[float]] A tuple storing information about the detected peaks. The tuple has the following elements: The first entry stores the number of peaks that were detected in the data frame. The second entry is a list storing the fractional fs indexes that locate the detected peaks in the data frame. The third entry is a list storing the fractional ss indexes that locate the the detected peaks in the data frame. The fourth entry is a list storing the integrated intensities for the detected peaks. The fifth entry is a list storing the number of pixels that make up each detected peak. The sixth entry is a list storing, for each peak, the value of the pixel with the maximum intensity. The seventh entry is a list storing the signal-to-noise ratio of each detected peak.","title":"peakfinder_8()"},{"location":"reference/om/parallelization_layer/","text":"parallelization_layer special OM's Parallelization Layer. This package contains OM's Parallelization Layer, which manages the communication between the processing and collecting nodes. It is split in several modules, each corresponding to a different inter-node communication protocol. base mpi","title":"__init__"},{"location":"reference/om/parallelization_layer/#om.parallelization_layer","text":"OM's Parallelization Layer. This package contains OM's Parallelization Layer, which manages the communication between the processing and collecting nodes. It is split in several modules, each corresponding to a different inter-node communication protocol. base mpi","title":"parallelization_layer"},{"location":"reference/om/parallelization_layer/base/","text":"base Parallelization Layer's base classes. This module contains base abstract classes for OM's Parallelization Layer. OmParallelizationEngine See documentation of the __init__ function. Base class: ABC __init__ ( self , data_event_handler , monitor , monitor_parameters ) special Base class for an OM's Parallelization Engine. Parallelization Engines orchestrate OM's processing and collecting nodes, and take care of the communication between them. This class is the base abstract class for all of OM's Parallelization Engines, and it should be subclassed to implement every Engine. All its methods are abstract: derived classes are expected to provide their own functions that implement a specific Parallelization Engine. When OM start, each Parallelization Engine initializes several processing nodes and a single collecting node. A Data Event Handler (an instance of a class derived from OmDataEventHandler ) and a Monitor (an instance of a class derived from OmMonitor ) must be provided to its constructor. On each processing node, the Engine retrieves one data event from a source by calling the relevant Data Event Handler methods. It then invokes the appropriate Monitor methods to process every frame in the retrieved event. The Engine also makes sure that the processed data is transferred to the collecting node. On the collecting node, the Engine invokes the relevant Monitor methods to aggregate data received from the processing nodes. When all events from the source have been processed, the Engine performs some final clean-up tasks defined in the Data Event Handler, then it shuts all the nodes down. Parameters: Name Type Description Default data_event_handler OmDataEventHandler A class defining how data events are retrieved and handled. required monitor OmMonitor A class defining the how the retrieved data must be processed. required monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required shutdown ( self , msg = 'Reason not provided.' ) Shuts down the parallelization engine. This function stops the processing and collecting nodes. When this function is called on a processing node, the processing node communicates to the collecting node that it is shutting down, then shuts down. When this function is called on the collecting node, the collecting node tells each processing node to shut down, waits for all the processing nodes to confirm that they have stopped operating, then shuts itself down. Parameters: Name Type Description Default msg Optional[str] Reason for shutting down the parallelization engine. Defaults to \"Reason not provided\". 'Reason not provided.' start ( self ) Starts the parallelization engine. This function begins operations on the processing and collecting nodes. When this function is called on a processing node, the node starts retrieving data events and processing them. When this function is called on the collecting node, the node starts receiving data from the processing nodes and aggregating it.","title":"base"},{"location":"reference/om/parallelization_layer/base/#om.parallelization_layer.base","text":"Parallelization Layer's base classes. This module contains base abstract classes for OM's Parallelization Layer.","title":"base"},{"location":"reference/om/parallelization_layer/base/#om.parallelization_layer.base.OmParallelizationEngine","text":"See documentation of the __init__ function. Base class: ABC","title":"OmParallelizationEngine"},{"location":"reference/om/parallelization_layer/base/#om.parallelization_layer.base.OmParallelizationEngine.__init__","text":"Base class for an OM's Parallelization Engine. Parallelization Engines orchestrate OM's processing and collecting nodes, and take care of the communication between them. This class is the base abstract class for all of OM's Parallelization Engines, and it should be subclassed to implement every Engine. All its methods are abstract: derived classes are expected to provide their own functions that implement a specific Parallelization Engine. When OM start, each Parallelization Engine initializes several processing nodes and a single collecting node. A Data Event Handler (an instance of a class derived from OmDataEventHandler ) and a Monitor (an instance of a class derived from OmMonitor ) must be provided to its constructor. On each processing node, the Engine retrieves one data event from a source by calling the relevant Data Event Handler methods. It then invokes the appropriate Monitor methods to process every frame in the retrieved event. The Engine also makes sure that the processed data is transferred to the collecting node. On the collecting node, the Engine invokes the relevant Monitor methods to aggregate data received from the processing nodes. When all events from the source have been processed, the Engine performs some final clean-up tasks defined in the Data Event Handler, then it shuts all the nodes down. Parameters: Name Type Description Default data_event_handler OmDataEventHandler A class defining how data events are retrieved and handled. required monitor OmMonitor A class defining the how the retrieved data must be processed. required monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required","title":"__init__()"},{"location":"reference/om/parallelization_layer/base/#om.parallelization_layer.base.OmParallelizationEngine.shutdown","text":"Shuts down the parallelization engine. This function stops the processing and collecting nodes. When this function is called on a processing node, the processing node communicates to the collecting node that it is shutting down, then shuts down. When this function is called on the collecting node, the collecting node tells each processing node to shut down, waits for all the processing nodes to confirm that they have stopped operating, then shuts itself down. Parameters: Name Type Description Default msg Optional[str] Reason for shutting down the parallelization engine. Defaults to \"Reason not provided\". 'Reason not provided.'","title":"shutdown()"},{"location":"reference/om/parallelization_layer/base/#om.parallelization_layer.base.OmParallelizationEngine.start","text":"Starts the parallelization engine. This function begins operations on the processing and collecting nodes. When this function is called on a processing node, the node starts retrieving data events and processing them. When this function is called on the collecting node, the node starts receiving data from the processing nodes and aggregating it.","title":"start()"},{"location":"reference/om/parallelization_layer/mpi/","text":"mpi MPI-based Parallelization Engine for OM. This module contains a Parallelization Engine for OM which uses the MPI communication rotocol to manage the communication between the nodes. MpiParallelizationEngine See documentation of the __init__ function. Base class: OmParallelizationEngine __init__ ( self , data_event_handler , monitor , monitor_parameters ) special MPI-based Parallelization Engine for OM. This class implements a Parallelization Engine based on the MPI protocol. It is a subclass of the OmParallelizationEngine base class. In this Engine, the nodes communicate with each other using an implementation of the MPI protocol supported by the Python language. Parameters: Name Type Description Default data_event_handler OmDataEventHandler A class defining how data events are retrieved and handled. required monitor OmMonitor A class defining the how the retrieved data must be processed. required monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required shutdown ( self , msg = 'Reason not provided.' ) Shuts down the MPI parallelization engine. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. When OM stops, this function closes the communication between the processing and collecting nodes, and manages a controlled shutdown of OM's resources, terminating the MPI processes in an orderly fashion. Parameters: Name Type Description Default msg Optional[str] Reason for shutting down the parallelization engine. Defaults to \"Reason not provided\". 'Reason not provided.' start ( self ) Starts the MPI parallelization engine. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function sets up the communication between OM's collecting and processing nodes using the MPI protocol. Additionally, it manages the interaction between the nodes while OM is running, receiving and dispatching data and control commands over MPI channels.","title":"mpi"},{"location":"reference/om/parallelization_layer/mpi/#om.parallelization_layer.mpi","text":"MPI-based Parallelization Engine for OM. This module contains a Parallelization Engine for OM which uses the MPI communication rotocol to manage the communication between the nodes.","title":"mpi"},{"location":"reference/om/parallelization_layer/mpi/#om.parallelization_layer.mpi.MpiParallelizationEngine","text":"See documentation of the __init__ function. Base class: OmParallelizationEngine","title":"MpiParallelizationEngine"},{"location":"reference/om/parallelization_layer/mpi/#om.parallelization_layer.mpi.MpiParallelizationEngine.__init__","text":"MPI-based Parallelization Engine for OM. This class implements a Parallelization Engine based on the MPI protocol. It is a subclass of the OmParallelizationEngine base class. In this Engine, the nodes communicate with each other using an implementation of the MPI protocol supported by the Python language. Parameters: Name Type Description Default data_event_handler OmDataEventHandler A class defining how data events are retrieved and handled. required monitor OmMonitor A class defining the how the retrieved data must be processed. required monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required","title":"__init__()"},{"location":"reference/om/parallelization_layer/mpi/#om.parallelization_layer.mpi.MpiParallelizationEngine.shutdown","text":"Shuts down the MPI parallelization engine. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. When OM stops, this function closes the communication between the processing and collecting nodes, and manages a controlled shutdown of OM's resources, terminating the MPI processes in an orderly fashion. Parameters: Name Type Description Default msg Optional[str] Reason for shutting down the parallelization engine. Defaults to \"Reason not provided\". 'Reason not provided.'","title":"shutdown()"},{"location":"reference/om/parallelization_layer/mpi/#om.parallelization_layer.mpi.MpiParallelizationEngine.start","text":"Starts the MPI parallelization engine. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function sets up the communication between OM's collecting and processing nodes using the MPI protocol. Additionally, it manages the interaction between the nodes while OM is running, receiving and dispatching data and control commands over MPI channels.","title":"start()"},{"location":"reference/om/processing_layer/","text":"processing_layer special OM's Processing Layer. This package contains OM's Processing Layer. This is where the pipeline of scientific data analysis for all kind of monitors is defined. Each module in this package contains the implementation of a different type of OnDA Monitor. base crystallography","title":"__init__"},{"location":"reference/om/processing_layer/#om.processing_layer","text":"OM's Processing Layer. This package contains OM's Processing Layer. This is where the pipeline of scientific data analysis for all kind of monitors is defined. Each module in this package contains the implementation of a different type of OnDA Monitor. base crystallography","title":"processing_layer"},{"location":"reference/om/processing_layer/base/","text":"base Parallelization Layer's base classes. This module contains base abstract classes for OM's Proceessing Layer. OmMonitor See documentation for the __init__ function. __init__ ( self , monitor_parameters ) special Base class for an OM's Monitor. Monitors implement scientific data processing pipelines in OM. A Monitor class has methods that define how single data events are processed on the processing nodes and how multi-event data is aggregated on the collecting node. Other methods describe actions that OM should perform when all data events from a source have been processed. This class is the base abstract class for all OM's Monitors. It should be subclassed to implement each specific Monitor. All its methods are virtual: each derived class is expected to provide its own functions that implement the Monitor's data processing logic. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required collect_data ( self , node_rank , node_pool_size , processed_data ) Collects processed data from a processing node. This is an abstract method. This function is invoked on the collecting node every time data is transferred from a processing node. The function accepts as input the data received from the processing node (the object returned by the :func: process_data function). This function usually computes aggregate statistics on the data received from all the nodes. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required processed_data Tuple[Dict[str, Any], int] A tuple whose first entry is a dictionary storing the data received from a processing node, and whose second entry is the OM rank number of the node that processed the information. required end_processing_on_collecting_node ( self , node_rank , node_pool_size ) Executes end-of-processing actions on the collecting node. This function is called by the parallelization engine on the collecting node at the end of the processing, immediately before OM stops. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required end_processing_on_processing_node ( self , node_rank , node_pool_size ) Executes end-of-processing actions on a processing node. This function is called by the Parallelization Engine on the processing nodes at the end of the processing, immediately before OM stops. The function usually does not return any value, but can optionally return a dictionary. In this case the Parallelization Engine makes sure that the dictionary is sent to the collecting node before the processing node shuts down. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Optional[Dict[str, Any]] A dictionary storing information to be sent to the processing node (Optional: if this function returns nothing, no information is transferred to the processing node). initialize_collecting_node ( self , node_rank , node_pool_size ) Initializes an OM collecting node. This is an abstract method. This function is invoked on the collecting node when OM starts and it prepares the node for the aggregation of data received from the processing nodes: it initializes the algorithms with the required parameters, creates data event buffers, etc. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required initialize_processing_node ( self , node_rank , node_pool_size ) Initializes an OM processing node. This is an abstract method. This function is invoked on each processing node when OM starts and it prepares the node to begin retrieveing and processing data events: it reads additional external data, initializes the algorithms with the required parameters, etc. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required process_data ( self , node_rank , node_pool_size , data ) Processes a single frame in a data event. This is an abstract method. This function is invoked on each processing node for every detector data frame in a data event. It receives a dictionary storing the raw frame data as input, and returns a dictionary with the processed data. OM's Parallelization Engine will make sure that the output of this function is tranferred to the collecting node. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required data Dict[str, Any] A dictionary containing the data retrieved by OM for the detector data frame being processed. The dictionary keys must match the entries in the 'required_data' list in the 'om' parameter group of the configuration file. The corresponding dictionary values must store the retrieved data for the frame currently being processed. required Returns: Type Description Tuple[Dict[str, Any], int] A tuple whose first entry is a dictionary storing the data that should be sent to the collecting node, and whose second entry is the OM rank number of the node that processed the information.","title":"base"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base","text":"Parallelization Layer's base classes. This module contains base abstract classes for OM's Proceessing Layer.","title":"base"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base.OmMonitor","text":"See documentation for the __init__ function.","title":"OmMonitor"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base.OmMonitor.__init__","text":"Base class for an OM's Monitor. Monitors implement scientific data processing pipelines in OM. A Monitor class has methods that define how single data events are processed on the processing nodes and how multi-event data is aggregated on the collecting node. Other methods describe actions that OM should perform when all data events from a source have been processed. This class is the base abstract class for all OM's Monitors. It should be subclassed to implement each specific Monitor. All its methods are virtual: each derived class is expected to provide its own functions that implement the Monitor's data processing logic. Parameters: Name Type Description Default monitor_parameters MonitorParams A MonitorParams object storing the OM monitor parameters from the configuration file. required","title":"__init__()"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base.OmMonitor.collect_data","text":"Collects processed data from a processing node. This is an abstract method. This function is invoked on the collecting node every time data is transferred from a processing node. The function accepts as input the data received from the processing node (the object returned by the :func: process_data function). This function usually computes aggregate statistics on the data received from all the nodes. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required processed_data Tuple[Dict[str, Any], int] A tuple whose first entry is a dictionary storing the data received from a processing node, and whose second entry is the OM rank number of the node that processed the information. required","title":"collect_data()"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base.OmMonitor.end_processing_on_collecting_node","text":"Executes end-of-processing actions on the collecting node. This function is called by the parallelization engine on the collecting node at the end of the processing, immediately before OM stops. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"end_processing_on_collecting_node()"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base.OmMonitor.end_processing_on_processing_node","text":"Executes end-of-processing actions on a processing node. This function is called by the Parallelization Engine on the processing nodes at the end of the processing, immediately before OM stops. The function usually does not return any value, but can optionally return a dictionary. In this case the Parallelization Engine makes sure that the dictionary is sent to the collecting node before the processing node shuts down. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description Optional[Dict[str, Any]] A dictionary storing information to be sent to the processing node (Optional: if this function returns nothing, no information is transferred to the processing node).","title":"end_processing_on_processing_node()"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base.OmMonitor.initialize_collecting_node","text":"Initializes an OM collecting node. This is an abstract method. This function is invoked on the collecting node when OM starts and it prepares the node for the aggregation of data received from the processing nodes: it initializes the algorithms with the required parameters, creates data event buffers, etc. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"initialize_collecting_node()"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base.OmMonitor.initialize_processing_node","text":"Initializes an OM processing node. This is an abstract method. This function is invoked on each processing node when OM starts and it prepares the node to begin retrieveing and processing data events: it reads additional external data, initializes the algorithms with the required parameters, etc. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"initialize_processing_node()"},{"location":"reference/om/processing_layer/base/#om.processing_layer.base.OmMonitor.process_data","text":"Processes a single frame in a data event. This is an abstract method. This function is invoked on each processing node for every detector data frame in a data event. It receives a dictionary storing the raw frame data as input, and returns a dictionary with the processed data. OM's Parallelization Engine will make sure that the output of this function is tranferred to the collecting node. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required data Dict[str, Any] A dictionary containing the data retrieved by OM for the detector data frame being processed. The dictionary keys must match the entries in the 'required_data' list in the 'om' parameter group of the configuration file. The corresponding dictionary values must store the retrieved data for the frame currently being processed. required Returns: Type Description Tuple[Dict[str, Any], int] A tuple whose first entry is a dictionary storing the data that should be sent to the collecting node, and whose second entry is the OM rank number of the node that processed the information.","title":"process_data()"},{"location":"reference/om/processing_layer/crystallography/","text":"crystallography OnDA Monitor for Crystallography. This module contains an OnDA Monitor for serial x-ray crystallography experiments. CrystallographyMonitor See documentation for the __init__ function. Base class: OmMonitor __init__ ( self , monitor_parameters ) special OnDA real-time Monitor for serial x-ray crystallography experiments. This class contains an OnDA Monitor that processes detector data frames, optionally applying detector calibration, dark correction and gain correction. The Monitor then detects Bragg peaks in each detector frame using the 'peakfinder8' peak detection algorithm from the Cheetah software package. It retrieves information about the location, size and intensity of each peak. Additionally, it calculates the evolution of the hit rate over time. It broadcasts all this information over a network socket for visualization by other programs. This OnDA Monitor can also optionally broadcast calibrated and corrected detector data frames to be displayed by an external program. This class is a subclass of the OmMonitor base class. Parameters: Name Type Description Default monitor_parameters MonitorParams A [MonitorParams] [om.utils.parameters.MonitorParams] object storing the OM monitor parameters from the configuration file. required collect_data ( self , node_rank , node_pool_size , processed_data ) Computes aggregated Bragg peak data and broadcasts it over the network. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function collects the Bragg peak information from the processing nodes and computes the average hit rate and a virtual powder pattern. It then broadcasts this information over a network socket for visualization by external programs. This function also broadcasts any detector frame data received from the processing nodes. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required processed_data Tuple[Dict[str, Any], int] a tuple whose first entry is a dictionary storing the data received from a processing node, and whose second entry is the OM rank number of the node that processed the information. required end_processing_on_collecting_node ( self , node_rank , node_pool_size ) Ends processing on the collecting node. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function prints a message on the console and ends the processing. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required end_processing_on_processing_node ( self , node_rank , node_pool_size ) Ends processing actions on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function prints a message on the console and ends the processing. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description None A dictionary storing information to be sent to the processing node (Optional: if this function returns nothing, no information is transferred to the processing node. initialize_collecting_node ( self , node_rank , node_pool_size ) Initializes the OM collecting node for the Crystallography Monitor. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function initializes the data accumulation algorithms and the storage buffers used to compute statistics on the detected Bragg peaks. Additionally, it prepares the data broadcasting socket to send data to external programs. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required initialize_processing_node ( self , node_rank , node_pool_size ) Initializes the OM processing nodes for the Crystallography Monitor. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function initializes the correction and peak finding algorithms, plus some internal counters. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required process_data ( self , node_rank , node_pool_size , data ) Processes a detector data frame and extracts Bragg peak information. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function performs calibration and correction of a detector data frame and extracts Bragg peak information. Finally, it prepares the Bragg peak data (and optionally, the detector frame data) for transmission to to the collecting node. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required data Dict[str, Any] A dictionary containing the data retrieved by OM for the frame being processed. The dictionary keys must match the entries in the 'required_data' list found in the 'om' parameter group in the configuration file. The corresponding dictionary values must store the retrieved data. required Returns: Type Description Tuple[Dict[str, Any], int] A tuple whose first entry is a dictionary storing the data that should be sent to the collecting node, and whose second entry is the OM rank number of the node that processed the information.","title":"crystallography"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography","text":"OnDA Monitor for Crystallography. This module contains an OnDA Monitor for serial x-ray crystallography experiments.","title":"crystallography"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography.CrystallographyMonitor","text":"See documentation for the __init__ function. Base class: OmMonitor","title":"CrystallographyMonitor"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography.CrystallographyMonitor.__init__","text":"OnDA real-time Monitor for serial x-ray crystallography experiments. This class contains an OnDA Monitor that processes detector data frames, optionally applying detector calibration, dark correction and gain correction. The Monitor then detects Bragg peaks in each detector frame using the 'peakfinder8' peak detection algorithm from the Cheetah software package. It retrieves information about the location, size and intensity of each peak. Additionally, it calculates the evolution of the hit rate over time. It broadcasts all this information over a network socket for visualization by other programs. This OnDA Monitor can also optionally broadcast calibrated and corrected detector data frames to be displayed by an external program. This class is a subclass of the OmMonitor base class. Parameters: Name Type Description Default monitor_parameters MonitorParams A [MonitorParams] [om.utils.parameters.MonitorParams] object storing the OM monitor parameters from the configuration file. required","title":"__init__()"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography.CrystallographyMonitor.collect_data","text":"Computes aggregated Bragg peak data and broadcasts it over the network. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function collects the Bragg peak information from the processing nodes and computes the average hit rate and a virtual powder pattern. It then broadcasts this information over a network socket for visualization by external programs. This function also broadcasts any detector frame data received from the processing nodes. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required processed_data Tuple[Dict[str, Any], int] a tuple whose first entry is a dictionary storing the data received from a processing node, and whose second entry is the OM rank number of the node that processed the information. required","title":"collect_data()"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography.CrystallographyMonitor.end_processing_on_collecting_node","text":"Ends processing on the collecting node. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function prints a message on the console and ends the processing. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"end_processing_on_collecting_node()"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography.CrystallographyMonitor.end_processing_on_processing_node","text":"Ends processing actions on the processing nodes. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function prints a message on the console and ends the processing. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required Returns: Type Description None A dictionary storing information to be sent to the processing node (Optional: if this function returns nothing, no information is transferred to the processing node.","title":"end_processing_on_processing_node()"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography.CrystallographyMonitor.initialize_collecting_node","text":"Initializes the OM collecting node for the Crystallography Monitor. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function initializes the data accumulation algorithms and the storage buffers used to compute statistics on the detected Bragg peaks. Additionally, it prepares the data broadcasting socket to send data to external programs. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"initialize_collecting_node()"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography.CrystallographyMonitor.initialize_processing_node","text":"Initializes the OM processing nodes for the Crystallography Monitor. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function initializes the correction and peak finding algorithms, plus some internal counters. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required","title":"initialize_processing_node()"},{"location":"reference/om/processing_layer/crystallography/#om.processing_layer.crystallography.CrystallographyMonitor.process_data","text":"Processes a detector data frame and extracts Bragg peak information. This method overrides the corresponding method of the base class: please also refer to the documentation of that class for more information. This function performs calibration and correction of a detector data frame and extracts Bragg peak information. Finally, it prepares the Bragg peak data (and optionally, the detector frame data) for transmission to to the collecting node. Parameters: Name Type Description Default node_rank int The OM rank of the current node, which is an integer that unambiguously identifies the current node in the OM node pool. required node_pool_size int The total number of nodes in the OM pool, including all the processing nodes and the collecting node. required data Dict[str, Any] A dictionary containing the data retrieved by OM for the frame being processed. The dictionary keys must match the entries in the 'required_data' list found in the 'om' parameter group in the configuration file. The corresponding dictionary values must store the retrieved data. required Returns: Type Description Tuple[Dict[str, Any], int] A tuple whose first entry is a dictionary storing the data that should be sent to the collecting node, and whose second entry is the OM rank number of the node that processed the information.","title":"process_data()"},{"location":"reference/om/utils/","text":"utils special OM's utility functions and classes. This package contains several helper functions and classes. They perform tasks needed by other parts of OM. They are grouped into several categories, each corresponding to a separate module. crystfel_geometry exceptions parameters zmq_gui zmq_moitor","title":"__init__"},{"location":"reference/om/utils/#om.utils","text":"OM's utility functions and classes. This package contains several helper functions and classes. They perform tasks needed by other parts of OM. They are grouped into several categories, each corresponding to a separate module. crystfel_geometry exceptions parameters zmq_gui zmq_moitor","title":"utils"},{"location":"reference/om/utils/crystfel_geometry/","text":"crystfel_geometry CrystFEL's geometry utilities. This module contains functions that manipulate geometry data encoded with the format used by the CrystFEL software package. TypeBadRegion A dictionary storing information about bad regions in a detector. Base class : TypedDict Attributes: Name Type Description panel str The name of the panel in which the bad region lies. min_x float The initial x coordinate of the bad region in the detector reference system. max_x float The final x coordinate of the bad region in the detector reference system. min_y float The initial y coordinate of the bad region in the detector reference system. max_y float The final y coordinate of the bad region in the detector reference system. min_fs int The initial fs index of the bad region in the block where the panel data is stored. max_fs int The final (inclusive) fs index of the bad region in the block where the panel data is stored. min_ss int The initial ss index of the bad region in the block where the panel data is stored. max_ss int The final (inclusive) ss index of the bad region in the block where the panel data is stored. is_fsss int Whether the fs,ss definition of the bad region (as opposed to the x,y-based one) should be considered. If the value corresponding to this key is 1, the fs,ss-based definition of the bad region is considered the valid one. Otherwise, the definition in x,y coordinates is taken as valid. TypeBeam A dictionary storing information about the x-ray beam. Base class : TypedDict Attributes: Name Type Description photon_energy float The photon energy of the beam in eV. photon_energy_from str The location of the photon energy information in an HDF5 data file, in case the beam energy information is extracted from a file. photon_energy_scale float The scaling factor to be applied to the photon energy, in case the provided energy value is not in eV. TypeDetector A dictionary storing information about a detector. Base class : TypedDict Attributes: Name Type Description panels Dict[str, om.utils.crystfel_geometry.TypePanel] The panels in the detector. The value corresponding to this key is a dictionary containing information about the panels that make up the detector. In the dictionary, the keys are the panel names, and the values are TypePanel dictionaries. bad Dict[str, om.utils.crystfel_geometry.TypeBadRegion] The bad regions in the detector. The value corresponding to this key is a dictionary containing information about the bad regions in the detector. In the dictionary, the keys are the bad region names, and the values are additional TypeBadRegion dictionaries. mask_bad int The value used in a bad pixel mask to label a pixel as bad. mask_good int The value used in a bad pixel mask to label a pixel as good. rigid_groups Dict[str, List[str]] The rigid groups of panels in the detector. The value corresponding to this key is a dictionary containing information about the rigid groups. In the dictionary, the keys are the names of the rigid groups and the values are lists storing the names of the panels belonging to each group. rigid_group_collections Dict[str, List[str]] The collections of rigid groups of panels in the detector. The value corresponding to this key is a dictionary containing information about the rigid group collections. In the dictionary, the keys are the names of the rigid group collections and the values are lists storing the names of the rigid groups belonging to the collections. furthest_out_panel str The name of the panel where the furthest away pixel from the center of the detector reference system can be found. furthest_out_fs float The fs coordinate, within its panel, of the furthest away pixel from the center of the detector reference system. furthest_out_ss float The ss coordinate, within its panel, of the furthest away pixel from the center of the detector reference system. furthest_in_panel str The name of the panel where the closest pixel to the center of the detector reference system can be found. furthest_in_fs float The fs coordinate, within its panel, of the closest pixel to the center of the detector reference system. furthest_in_ss float The ss coordinate, within its panel, of the closest pixel to the center of the detector reference system. TypePanel A dictionary storing information about detector panels. Base class : TypedDict Attributes: Name Type Description cnx float The x location of the corner of the panel in the detector reference system. cny float The y location of the corner of the panel in the detector reference system. clen float The distance, as reported by the facility, of the sample interaction point from the corner of the first pixel in the panel. clen_from str The location of the 'clen' information in an HDF5 data file, in case the detector distance is extracted from a file. coffset float The offset to be applied to the nominal clen value reported by the facility in order to determine the real distance of the panel from the interaction point. mask str The location of the mask data for the panel in an HDF5 data file. mask_file str The name of the HDF5 data file in which the mask data for the panel can be found. satmap str The location of the per-pixel saturation map for the panel in an HDF5 data file. satmap_file str The name of the HDF5 data file in which the per-pixel saturation map for the panel can be found. res float The resolution of the panel in pixels per meter. badrow str The readout direction for the panel, for filtering out clusters of peaks. The value corresponding to this key is either 'x' or 'y'. no_index bool Wether the panel should be considered entirely bad. The panel will be considered bad if the value corresponding to this key is non-zero. adu_per_photon float The number of detector intensity units per photon for the panel. max_adu float The detector intensity unit value above which a pixel of the panel should be considered unreliable. data str The location, in an HDF5 data file, of the data block where the panel data is stored. adu_per_eV float The number of detector intensity units per eV of photon energy for the panel. dim_structure List[Union[int, str]] A description of the layout of the data block for the panel. The value corresponding to this key is a list of strings describing the meaning of each axis in the data block. See the crystfel_geometry man page for a detailed explanation. fsx float The fs->x component of the matrix used to transform pixel indexes into detector reference system coordinates. fsy float The fs->y component of the matrix used to transform pixel indexes into detector reference system coordinates. fsz float The fs->z component of the matrix used to transform pixel indexes into detector reference system coordinates. ssx float The ss->x component of the matrix used to transform pixel indexes into detector reference system coordinates. ssy float The ss->y component of the matrix used to transform pixel indexes into detector reference system coordinates. ssz float The ss->z component of the matrix used to transform pixel indexes into detector reference system coordinates. rail_x float The x component, in the detector reference system, of the direction of the rail along which the detector moves. rail_y float The y component, in the detector reference system, of the direction of the rail along which the detector moves. rail_z float The z component, in the detector reference system, of the direction of the rail along which the detector moves. clen_for_centering float The distance from the interation point, as reported by the facility, of the origin of the detector reference system. xfs float The x->fs component of the matrix used to transform detector reference system coordinates into pixel indexes. yfs float The y->fs component of the matrix used to transform detector reference system coordinates into pixel indexes. xss float The x->ss component of the matrix used to transform detector reference system coordinates into pixel indexes. yss float The y->ss component of the matrix used to transform detector reference system coordinates into pixel indexes. orig_min_fs int The initial fs index of the panel data in the data block where it is stored. orig_max_fs int The final (inclusive) fs index of the panel data in the data block where it is stored. orig_min_ss int The initial ss index of the panel data in the data block where it is stored. orig_max_ss int The final (inclusive) fs index of the panel data in the data block where it is stored. w int The width of the panel in pixels. h int The height of the panel in pixels. TypePixelMaps A dictionary storing a set of pixel maps. Base class : TypedDict Attributes: Name Type Description x ndarray A pixel map for the x coordinate. y ndarray A pixel map for the y coordinate. z Optional[numpy.ndarray] A pixel map for the z coordinate. radius Optional[numpy.ndarray] A pixel map storing the distance of each pixel from the center of the detector reference system. phi Optional[numpy.ndarray] A pixel map storing, for each pixel, the amplitude of the angle drawn by the pixel, the center of the detector reference system, and the x axis. apply_geometry_to_data ( data , geometry ) Applies CrystFEL geometry information to some data. This function takes as input the geometry information read from a CrystFEL <http://www.desy.de/~twhite/crystfel/manual-crystfel_geometry.html> geometry file, and some data on which the geometry information should be applied. It returns an array that can be displayed using libraries like matplotlib <https://matplotlib.org/> or PyQtGraph <http://pyqtgraph.org/> _. The shape of the returned array is big enough to display all the pixel values in the input data, and is symmetric around the center of the detector reference system (i.e: the beam interaction point). These restrictions often cause the returned array to be bigger than the minimum size needed to store the physical layout of the pixels in the detector, particularly if the detector is not centered at the beam interaction point. Parameters: Name Type Description Default data ndarray The data on which the geometry information should be applied. required geometry TypeDetector A TypeDetector dictionary storing the detector geometry information. required Returns: Type Description ndarray An array containing the data with the geometry information applied. compute_pix_maps ( geometry ) Computes pixel maps from CrystFEL geometry information. This function takes as input the geometry information read from a CrystFEL <http://www.desy.de/~twhite/crystfel/manual-crystfel_geometry.html> _ geometry file, and returns a set of pre-computed pixel maps. The origin and the orientation of the reference system for the pixel maps are set according to conventions used by CrystFEL: The center of the reference system is the beam interaction point. +z is the beam direction, and points along the beam (i.e. away from the source). +y points towards the zenith (ceiling). +x completes the right-handed coordinate system. Parameters: Name Type Description Default geometry TypeDetector A TypeDetector dictionary returned by the load_crystfel_geometry function, storing the detector geometry information. required Returns: Type Description TypePixelMaps A TypePixelMaps dictionary storing the pixel maps. compute_visualization_pix_maps ( geometry ) Computes pixel maps for data visualization from CrystFEL geometry information. This function takes as input the geometry information read from a CrystFEL geometry file , and returns a set of pre-computed pixel maps that can be used to display data in a Qt ImageView widget (from the PyQtGraph library). These pixel maps are different from the ones generated by the :func: ~compute_pix_maps function. The main differences are: The origin of the reference system is not the beam interaction point, but the top left corner of the array used to visualize the data. Only the x and y pixel maps are available. The other keys in the returned typed dictionary (z, r and phi) have a value of None. Parameters: Name Type Description Default geometry TypeDetector A TypeDetector dictionary returned by the load_crystfel_geometry function, storing the detector geometry information. required Returns: Type Description TypePixelMaps A TypePixelMaps dictionary storing the pixel maps. Only the values corresponding to the 'x' and 'y' keys are defined. All other dictionary values are set to None. load_crystfel_geometry ( filename ) Loads a CrystFEL geometry file. This function is a re-implementation of the get_detector_geometry_2 function from CrystFEL. It reads information from a CrystFEL geometry file, which uses a key/value language format, fully documented in the relevant man page . This function returns a set of nested dictionaries whose content matches CrystFEL's internal representation of the information in the file (see the libcrystfel/src/detector.h and the libcrystfel/src/image.c files from CrystFEL's source code for more information). The code of this function is currently synchronized with the code of the function 'get_detector_geometry_2' in CrystFEL at commit cff9159b4bc6. Parameters: Name Type Description Default filename str the absolute or relative path to a CrystFEL geometry file. required Returns: Type Description Tuple[om.utils.crystfel_geometry.TypeDetector, om.utils.crystfel_geometry.TypeBeam, str] A tuple with the information loaded from the file. The first entry in the tuple is a TypeDetector dictionary storing information related to the detector geometry. The second entry in the tuple is a TypeBeam dictionary storing the beam properties. The third entry is the location, within an HDF5 file, where Bragg peak information for the current detector can be found. If the CrystFEL geometry file does not provide this last piece information, this entry has the value of an empty string.","title":"crystfel_geometry"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry","text":"CrystFEL's geometry utilities. This module contains functions that manipulate geometry data encoded with the format used by the CrystFEL software package.","title":"crystfel_geometry"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.TypeBadRegion","text":"A dictionary storing information about bad regions in a detector. Base class : TypedDict Attributes: Name Type Description panel str The name of the panel in which the bad region lies. min_x float The initial x coordinate of the bad region in the detector reference system. max_x float The final x coordinate of the bad region in the detector reference system. min_y float The initial y coordinate of the bad region in the detector reference system. max_y float The final y coordinate of the bad region in the detector reference system. min_fs int The initial fs index of the bad region in the block where the panel data is stored. max_fs int The final (inclusive) fs index of the bad region in the block where the panel data is stored. min_ss int The initial ss index of the bad region in the block where the panel data is stored. max_ss int The final (inclusive) ss index of the bad region in the block where the panel data is stored. is_fsss int Whether the fs,ss definition of the bad region (as opposed to the x,y-based one) should be considered. If the value corresponding to this key is 1, the fs,ss-based definition of the bad region is considered the valid one. Otherwise, the definition in x,y coordinates is taken as valid.","title":"TypeBadRegion"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.TypeBeam","text":"A dictionary storing information about the x-ray beam. Base class : TypedDict Attributes: Name Type Description photon_energy float The photon energy of the beam in eV. photon_energy_from str The location of the photon energy information in an HDF5 data file, in case the beam energy information is extracted from a file. photon_energy_scale float The scaling factor to be applied to the photon energy, in case the provided energy value is not in eV.","title":"TypeBeam"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.TypeDetector","text":"A dictionary storing information about a detector. Base class : TypedDict Attributes: Name Type Description panels Dict[str, om.utils.crystfel_geometry.TypePanel] The panels in the detector. The value corresponding to this key is a dictionary containing information about the panels that make up the detector. In the dictionary, the keys are the panel names, and the values are TypePanel dictionaries. bad Dict[str, om.utils.crystfel_geometry.TypeBadRegion] The bad regions in the detector. The value corresponding to this key is a dictionary containing information about the bad regions in the detector. In the dictionary, the keys are the bad region names, and the values are additional TypeBadRegion dictionaries. mask_bad int The value used in a bad pixel mask to label a pixel as bad. mask_good int The value used in a bad pixel mask to label a pixel as good. rigid_groups Dict[str, List[str]] The rigid groups of panels in the detector. The value corresponding to this key is a dictionary containing information about the rigid groups. In the dictionary, the keys are the names of the rigid groups and the values are lists storing the names of the panels belonging to each group. rigid_group_collections Dict[str, List[str]] The collections of rigid groups of panels in the detector. The value corresponding to this key is a dictionary containing information about the rigid group collections. In the dictionary, the keys are the names of the rigid group collections and the values are lists storing the names of the rigid groups belonging to the collections. furthest_out_panel str The name of the panel where the furthest away pixel from the center of the detector reference system can be found. furthest_out_fs float The fs coordinate, within its panel, of the furthest away pixel from the center of the detector reference system. furthest_out_ss float The ss coordinate, within its panel, of the furthest away pixel from the center of the detector reference system. furthest_in_panel str The name of the panel where the closest pixel to the center of the detector reference system can be found. furthest_in_fs float The fs coordinate, within its panel, of the closest pixel to the center of the detector reference system. furthest_in_ss float The ss coordinate, within its panel, of the closest pixel to the center of the detector reference system.","title":"TypeDetector"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.TypePanel","text":"A dictionary storing information about detector panels. Base class : TypedDict Attributes: Name Type Description cnx float The x location of the corner of the panel in the detector reference system. cny float The y location of the corner of the panel in the detector reference system. clen float The distance, as reported by the facility, of the sample interaction point from the corner of the first pixel in the panel. clen_from str The location of the 'clen' information in an HDF5 data file, in case the detector distance is extracted from a file. coffset float The offset to be applied to the nominal clen value reported by the facility in order to determine the real distance of the panel from the interaction point. mask str The location of the mask data for the panel in an HDF5 data file. mask_file str The name of the HDF5 data file in which the mask data for the panel can be found. satmap str The location of the per-pixel saturation map for the panel in an HDF5 data file. satmap_file str The name of the HDF5 data file in which the per-pixel saturation map for the panel can be found. res float The resolution of the panel in pixels per meter. badrow str The readout direction for the panel, for filtering out clusters of peaks. The value corresponding to this key is either 'x' or 'y'. no_index bool Wether the panel should be considered entirely bad. The panel will be considered bad if the value corresponding to this key is non-zero. adu_per_photon float The number of detector intensity units per photon for the panel. max_adu float The detector intensity unit value above which a pixel of the panel should be considered unreliable. data str The location, in an HDF5 data file, of the data block where the panel data is stored. adu_per_eV float The number of detector intensity units per eV of photon energy for the panel. dim_structure List[Union[int, str]] A description of the layout of the data block for the panel. The value corresponding to this key is a list of strings describing the meaning of each axis in the data block. See the crystfel_geometry man page for a detailed explanation. fsx float The fs->x component of the matrix used to transform pixel indexes into detector reference system coordinates. fsy float The fs->y component of the matrix used to transform pixel indexes into detector reference system coordinates. fsz float The fs->z component of the matrix used to transform pixel indexes into detector reference system coordinates. ssx float The ss->x component of the matrix used to transform pixel indexes into detector reference system coordinates. ssy float The ss->y component of the matrix used to transform pixel indexes into detector reference system coordinates. ssz float The ss->z component of the matrix used to transform pixel indexes into detector reference system coordinates. rail_x float The x component, in the detector reference system, of the direction of the rail along which the detector moves. rail_y float The y component, in the detector reference system, of the direction of the rail along which the detector moves. rail_z float The z component, in the detector reference system, of the direction of the rail along which the detector moves. clen_for_centering float The distance from the interation point, as reported by the facility, of the origin of the detector reference system. xfs float The x->fs component of the matrix used to transform detector reference system coordinates into pixel indexes. yfs float The y->fs component of the matrix used to transform detector reference system coordinates into pixel indexes. xss float The x->ss component of the matrix used to transform detector reference system coordinates into pixel indexes. yss float The y->ss component of the matrix used to transform detector reference system coordinates into pixel indexes. orig_min_fs int The initial fs index of the panel data in the data block where it is stored. orig_max_fs int The final (inclusive) fs index of the panel data in the data block where it is stored. orig_min_ss int The initial ss index of the panel data in the data block where it is stored. orig_max_ss int The final (inclusive) fs index of the panel data in the data block where it is stored. w int The width of the panel in pixels. h int The height of the panel in pixels.","title":"TypePanel"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.TypePixelMaps","text":"A dictionary storing a set of pixel maps. Base class : TypedDict Attributes: Name Type Description x ndarray A pixel map for the x coordinate. y ndarray A pixel map for the y coordinate. z Optional[numpy.ndarray] A pixel map for the z coordinate. radius Optional[numpy.ndarray] A pixel map storing the distance of each pixel from the center of the detector reference system. phi Optional[numpy.ndarray] A pixel map storing, for each pixel, the amplitude of the angle drawn by the pixel, the center of the detector reference system, and the x axis.","title":"TypePixelMaps"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.apply_geometry_to_data","text":"Applies CrystFEL geometry information to some data. This function takes as input the geometry information read from a CrystFEL <http://www.desy.de/~twhite/crystfel/manual-crystfel_geometry.html> geometry file, and some data on which the geometry information should be applied. It returns an array that can be displayed using libraries like matplotlib <https://matplotlib.org/> or PyQtGraph <http://pyqtgraph.org/> _. The shape of the returned array is big enough to display all the pixel values in the input data, and is symmetric around the center of the detector reference system (i.e: the beam interaction point). These restrictions often cause the returned array to be bigger than the minimum size needed to store the physical layout of the pixels in the detector, particularly if the detector is not centered at the beam interaction point. Parameters: Name Type Description Default data ndarray The data on which the geometry information should be applied. required geometry TypeDetector A TypeDetector dictionary storing the detector geometry information. required Returns: Type Description ndarray An array containing the data with the geometry information applied.","title":"apply_geometry_to_data()"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.compute_pix_maps","text":"Computes pixel maps from CrystFEL geometry information. This function takes as input the geometry information read from a CrystFEL <http://www.desy.de/~twhite/crystfel/manual-crystfel_geometry.html> _ geometry file, and returns a set of pre-computed pixel maps. The origin and the orientation of the reference system for the pixel maps are set according to conventions used by CrystFEL: The center of the reference system is the beam interaction point. +z is the beam direction, and points along the beam (i.e. away from the source). +y points towards the zenith (ceiling). +x completes the right-handed coordinate system. Parameters: Name Type Description Default geometry TypeDetector A TypeDetector dictionary returned by the load_crystfel_geometry function, storing the detector geometry information. required Returns: Type Description TypePixelMaps A TypePixelMaps dictionary storing the pixel maps.","title":"compute_pix_maps()"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.compute_visualization_pix_maps","text":"Computes pixel maps for data visualization from CrystFEL geometry information. This function takes as input the geometry information read from a CrystFEL geometry file , and returns a set of pre-computed pixel maps that can be used to display data in a Qt ImageView widget (from the PyQtGraph library). These pixel maps are different from the ones generated by the :func: ~compute_pix_maps function. The main differences are: The origin of the reference system is not the beam interaction point, but the top left corner of the array used to visualize the data. Only the x and y pixel maps are available. The other keys in the returned typed dictionary (z, r and phi) have a value of None. Parameters: Name Type Description Default geometry TypeDetector A TypeDetector dictionary returned by the load_crystfel_geometry function, storing the detector geometry information. required Returns: Type Description TypePixelMaps A TypePixelMaps dictionary storing the pixel maps. Only the values corresponding to the 'x' and 'y' keys are defined. All other dictionary values are set to None.","title":"compute_visualization_pix_maps()"},{"location":"reference/om/utils/crystfel_geometry/#om.utils.crystfel_geometry.load_crystfel_geometry","text":"Loads a CrystFEL geometry file. This function is a re-implementation of the get_detector_geometry_2 function from CrystFEL. It reads information from a CrystFEL geometry file, which uses a key/value language format, fully documented in the relevant man page . This function returns a set of nested dictionaries whose content matches CrystFEL's internal representation of the information in the file (see the libcrystfel/src/detector.h and the libcrystfel/src/image.c files from CrystFEL's source code for more information). The code of this function is currently synchronized with the code of the function 'get_detector_geometry_2' in CrystFEL at commit cff9159b4bc6. Parameters: Name Type Description Default filename str the absolute or relative path to a CrystFEL geometry file. required Returns: Type Description Tuple[om.utils.crystfel_geometry.TypeDetector, om.utils.crystfel_geometry.TypeBeam, str] A tuple with the information loaded from the file. The first entry in the tuple is a TypeDetector dictionary storing information related to the detector geometry. The second entry in the tuple is a TypeBeam dictionary storing the beam properties. The third entry is the location, within an HDF5 file, where Bragg peak information for the current detector can be found. If the CrystFEL geometry file does not provide this last piece information, this entry has the value of an empty string.","title":"load_crystfel_geometry()"},{"location":"reference/om/utils/exceptions/","text":"exceptions OM-specific exceptions and exception handling. This module contains a set of python exceptions that are specific to OM, and a custom exception handler that reports the OM exceptions in a simplified way. OmConfigurationFileReadingError Raised if an error happens while reading the configuration file. Base class: OmException OmConfigurationFileSyntaxError Raised if there is a syntax error in the configuration file. Base class: OmException OmDataExtractionError Raised if an error happens during data extraction. Base class: OmException OmException Base class for OM exceptions. Base class: Exception All other OM-specific exceptions should subclass from this exception. OmHdf5FileReadingError Raised if an error happens while reading an HDF5 file. Base class: OmException OmHdf5PathError Raised if an internal HDF5 path is not found. Base class: OmException OmHidraAPIError Raised if an error happens during a HiDRA API call. Base class: OmException OmInvalidDataBroadcastUrl Raised if the format of the data broadcasting URL is not valid. Base class: OmException OmInvalidRespondingUrl Raised if the format of the responding socket's URL is not valid. Base class: OmException OmInvalidSourceError Raised if the format of the source string is not valid. Base class: OmException OmMissingDataEventHandlerError Raised if the implementation of a data event handler cannot be found on the system. Base class: OmException OmMissingDataExtractionFunctionError Raised if a Data Extraction Function is not defined. Base class: OmException OmMissingDependencyError Raised if one of the python module dependencies is not found on the system. Base class: OmException OmMissingLayerModuleFileError Raised if the python implementation of an OM layer cannot be found on the system. Base class: OmException OmMissingParameterError Raised if a parameter is missing from the configuration file. Base class: OmException OmMissingParameterGroupError Raised if a parameter group is missing from the configuration file. Base class: OmException OmMissingPsanaInitializationFunctionError Raised if a psana Detector interface initialization Function is not defined. Base class: OmException OmWrongParameterTypeError Raised if the type of a configuration parameter does not match the requested type. Base class: OmException om_exception_handler ( parameter_type , value , traceback_ ) Custom OM exception handler. This function should never be called directly. Instead it should be used as a replacement for the standard exception handler. For all OM exceptions, this handler adds a label to the exception and hides the stacktrace. All non-OM exceptions are instead reported normally. Parameters: Name Type Description Default parameter_type Exception exception type. required value str exception value (the message that comes with the exception). required traceback_ str traceback to be printed. required","title":"exceptions"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions","text":"OM-specific exceptions and exception handling. This module contains a set of python exceptions that are specific to OM, and a custom exception handler that reports the OM exceptions in a simplified way.","title":"exceptions"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmConfigurationFileReadingError","text":"Raised if an error happens while reading the configuration file. Base class: OmException","title":"OmConfigurationFileReadingError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmConfigurationFileSyntaxError","text":"Raised if there is a syntax error in the configuration file. Base class: OmException","title":"OmConfigurationFileSyntaxError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmDataExtractionError","text":"Raised if an error happens during data extraction. Base class: OmException","title":"OmDataExtractionError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmException","text":"Base class for OM exceptions. Base class: Exception All other OM-specific exceptions should subclass from this exception.","title":"OmException"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmHdf5FileReadingError","text":"Raised if an error happens while reading an HDF5 file. Base class: OmException","title":"OmHdf5FileReadingError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmHdf5PathError","text":"Raised if an internal HDF5 path is not found. Base class: OmException","title":"OmHdf5PathError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmHidraAPIError","text":"Raised if an error happens during a HiDRA API call. Base class: OmException","title":"OmHidraAPIError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmInvalidDataBroadcastUrl","text":"Raised if the format of the data broadcasting URL is not valid. Base class: OmException","title":"OmInvalidDataBroadcastUrl"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmInvalidRespondingUrl","text":"Raised if the format of the responding socket's URL is not valid. Base class: OmException","title":"OmInvalidRespondingUrl"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmInvalidSourceError","text":"Raised if the format of the source string is not valid. Base class: OmException","title":"OmInvalidSourceError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmMissingDataEventHandlerError","text":"Raised if the implementation of a data event handler cannot be found on the system. Base class: OmException","title":"OmMissingDataEventHandlerError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmMissingDataExtractionFunctionError","text":"Raised if a Data Extraction Function is not defined. Base class: OmException","title":"OmMissingDataExtractionFunctionError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmMissingDependencyError","text":"Raised if one of the python module dependencies is not found on the system. Base class: OmException","title":"OmMissingDependencyError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmMissingLayerModuleFileError","text":"Raised if the python implementation of an OM layer cannot be found on the system. Base class: OmException","title":"OmMissingLayerModuleFileError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmMissingParameterError","text":"Raised if a parameter is missing from the configuration file. Base class: OmException","title":"OmMissingParameterError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmMissingParameterGroupError","text":"Raised if a parameter group is missing from the configuration file. Base class: OmException","title":"OmMissingParameterGroupError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmMissingPsanaInitializationFunctionError","text":"Raised if a psana Detector interface initialization Function is not defined. Base class: OmException","title":"OmMissingPsanaInitializationFunctionError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.OmWrongParameterTypeError","text":"Raised if the type of a configuration parameter does not match the requested type. Base class: OmException","title":"OmWrongParameterTypeError"},{"location":"reference/om/utils/exceptions/#om.utils.exceptions.om_exception_handler","text":"Custom OM exception handler. This function should never be called directly. Instead it should be used as a replacement for the standard exception handler. For all OM exceptions, this handler adds a label to the exception and hides the stacktrace. All non-OM exceptions are instead reported normally. Parameters: Name Type Description Default parameter_type Exception exception type. required value str exception value (the message that comes with the exception). required traceback_ str traceback to be printed. required","title":"om_exception_handler()"},{"location":"reference/om/utils/parameters/","text":"parameters OM's configuration parameter management. This module contains a class that can be used to manage and validate a set of configuration parameters read from a file. MonitorParams See documentation for the __init__ function. __init__ ( self , config ) special Storage, retrieval and validation of OM monitor parameters. This class stores a set of parameters, subdivided in groups, read from an OM configuration file written in YAML format. This class has methods to retrieve, and optionally validate, configuration parameters. Parameters: Name Type Description Default config str The absolute or relative path to a YAML-format configuration file. required Exceptions: Type Description OMConfigurationFileSyntaxError A OmConfigurationFileSyntaxError is raised if there is a syntax error in the configuration file. get_all_parameters ( self ) Returns the whole set of parameters read from the configuration file. Returns: Type Description Any A dictionary containing the parameters read from the configuration file. get_param ( self , group , parameter , parameter_type = None , required = False ) Retrieves an OM monitor configuration parameter. This function retrives a configuration parameter belonging to a parameter group. Optionally, it validates the type of the parameter. The function behaves according to the following rules: If the 'required' argument is True and the parameter cannot be found in the configuration file, this function will raise an exception. If the 'required' argument is False and the parameter cannot be found in the configuration file, this function will return None. If a type is specified in the function call (the 'parameter_type' argument is not None), this function will raise an exception if the type of the retrieved parameter does not match the specified one. Parameters: Name Type Description Default group str The name of the parameter group in which the parameter to retrieve is located. required parameter str The name of the parameter to retrieve. required parameter_type Any The type of the parameter. If a type is specified here, the type of the retrieved parameter will be validated. Defaults to None. None required bool True if the parameter is strictly required and must be present in the configuration file, False otherwise. Defaults to False. False Returns: Type Description Any The value of the requested parameter, or None, if the parameter was not found in the configuration file (and it is not required). Exceptions: Type Description OmMissingParameterGroupError A OmMissingParameterGroupError exception is raised if the requested parameter group is not present in the configuration file. OmMissingParameterError A OmMissingParameterError exception is raised if the parameter is required but cannot be found in the configuration file. OmWrongParameterTypeError A OmWrongParameterTypeError exception is raised if the requested parameter type does not match the type of the parameter in the configuration file.","title":"parameters"},{"location":"reference/om/utils/parameters/#om.utils.parameters","text":"OM's configuration parameter management. This module contains a class that can be used to manage and validate a set of configuration parameters read from a file.","title":"parameters"},{"location":"reference/om/utils/parameters/#om.utils.parameters.MonitorParams","text":"See documentation for the __init__ function.","title":"MonitorParams"},{"location":"reference/om/utils/parameters/#om.utils.parameters.MonitorParams.__init__","text":"Storage, retrieval and validation of OM monitor parameters. This class stores a set of parameters, subdivided in groups, read from an OM configuration file written in YAML format. This class has methods to retrieve, and optionally validate, configuration parameters. Parameters: Name Type Description Default config str The absolute or relative path to a YAML-format configuration file. required Exceptions: Type Description OMConfigurationFileSyntaxError A OmConfigurationFileSyntaxError is raised if there is a syntax error in the configuration file.","title":"__init__()"},{"location":"reference/om/utils/parameters/#om.utils.parameters.MonitorParams.get_all_parameters","text":"Returns the whole set of parameters read from the configuration file. Returns: Type Description Any A dictionary containing the parameters read from the configuration file.","title":"get_all_parameters()"},{"location":"reference/om/utils/parameters/#om.utils.parameters.MonitorParams.get_param","text":"Retrieves an OM monitor configuration parameter. This function retrives a configuration parameter belonging to a parameter group. Optionally, it validates the type of the parameter. The function behaves according to the following rules: If the 'required' argument is True and the parameter cannot be found in the configuration file, this function will raise an exception. If the 'required' argument is False and the parameter cannot be found in the configuration file, this function will return None. If a type is specified in the function call (the 'parameter_type' argument is not None), this function will raise an exception if the type of the retrieved parameter does not match the specified one. Parameters: Name Type Description Default group str The name of the parameter group in which the parameter to retrieve is located. required parameter str The name of the parameter to retrieve. required parameter_type Any The type of the parameter. If a type is specified here, the type of the retrieved parameter will be validated. Defaults to None. None required bool True if the parameter is strictly required and must be present in the configuration file, False otherwise. Defaults to False. False Returns: Type Description Any The value of the requested parameter, or None, if the parameter was not found in the configuration file (and it is not required). Exceptions: Type Description OmMissingParameterGroupError A OmMissingParameterGroupError exception is raised if the requested parameter group is not present in the configuration file. OmMissingParameterError A OmMissingParameterError exception is raised if the parameter is required but cannot be found in the configuration file. OmWrongParameterTypeError A OmWrongParameterTypeError exception is raised if the requested parameter type does not match the type of the parameter in the configuration file.","title":"get_param()"},{"location":"reference/om/utils/zmq_gui/","text":"zmq_gui ZMQ utilities to receive data from OnDA Monitors. This module contains classes and functions that allow external programs to receive data broadcasted by an OnDA Monitor over a network connection. ZmqDataListener See documentation for the __init__ function. zmqmessage : Any Qt signal emitted when a message is received by the GUI. This signal is emitted when the GUI receives data from an OnDA Monitor. It brings the received data as payload. __init__ ( self , url , tag ) special ZMQ-based data receiving socket for OM's graphical user interfaces. This class implements a ZMQ SUB socket that can be used to receive data from an OnDA Monitor. The socket accepts only data tagged with a specified label. Every time a message is received, this class emits a custom Qt signal that carries the received data as payload. This class is designed to be run in a separate Qt thread. Parameters: Name Type Description Default url str The URL where the socket will listen for data. It must be a string in the format used by ZeroMQ. required tag str The label used by the socket to filter incoming data. Only data whose label matches this argument will be accepted and received. required start_listening ( self ) Connects to a PUB socket and starts listening for data. This function connects the SUB socket to the URL specified when the class is instantiated. stop_listening ( self ) Stops listening to a PUB socket and disconnects. This function completely disconnects the SUB socket. It needs to be reconnected (using the :func: start_listening function) to start receiving data again.","title":"zmq_gui"},{"location":"reference/om/utils/zmq_gui/#om.utils.zmq_gui","text":"ZMQ utilities to receive data from OnDA Monitors. This module contains classes and functions that allow external programs to receive data broadcasted by an OnDA Monitor over a network connection.","title":"zmq_gui"},{"location":"reference/om/utils/zmq_gui/#om.utils.zmq_gui.ZmqDataListener","text":"See documentation for the __init__ function.","title":"ZmqDataListener"},{"location":"reference/om/utils/zmq_gui/#om.utils.zmq_gui.ZmqDataListener.zmqmessage","text":"Qt signal emitted when a message is received by the GUI. This signal is emitted when the GUI receives data from an OnDA Monitor. It brings the received data as payload.","title":"zmqmessage"},{"location":"reference/om/utils/zmq_gui/#om.utils.zmq_gui.ZmqDataListener.__init__","text":"ZMQ-based data receiving socket for OM's graphical user interfaces. This class implements a ZMQ SUB socket that can be used to receive data from an OnDA Monitor. The socket accepts only data tagged with a specified label. Every time a message is received, this class emits a custom Qt signal that carries the received data as payload. This class is designed to be run in a separate Qt thread. Parameters: Name Type Description Default url str The URL where the socket will listen for data. It must be a string in the format used by ZeroMQ. required tag str The label used by the socket to filter incoming data. Only data whose label matches this argument will be accepted and received. required","title":"__init__()"},{"location":"reference/om/utils/zmq_gui/#om.utils.zmq_gui.ZmqDataListener.start_listening","text":"Connects to a PUB socket and starts listening for data. This function connects the SUB socket to the URL specified when the class is instantiated.","title":"start_listening()"},{"location":"reference/om/utils/zmq_gui/#om.utils.zmq_gui.ZmqDataListener.stop_listening","text":"Stops listening to a PUB socket and disconnects. This function completely disconnects the SUB socket. It needs to be reconnected (using the :func: start_listening function) to start receiving data again.","title":"stop_listening()"},{"location":"reference/om/utils/zmq_monitor/","text":"zmq_monitor ZMQ utilities to broadcast data from an OnDA Monitor. This module contains classes and functions that allow OnDA Monitors to broadcast data to external programs over a network connection. ZmqDataBroadcaster See documentation of the __init__ function. __init__ ( self , url ) special ZMQ-based data-broadcasting socket for OnDA Monitors. This class implements a ZMQ PUB socket that can be used to broadcast data from an OnDA Monitor. The data must be tagged with a label when broadcast. The socket supports multiple simultaneous clients, but has no queuing system: broadcast data will be lost to the clients if not received before the next transmission takes place. Parameters: Name Type Description Default url Optional[str] The URL where the socket will be opened. It must be a string in the format used by ZeroMQ, or None. If the value of this argument is None, the IP address of the local machine will be autodetected, and the socket will be opened at port 12321 using the 'tcp://' protocol. Defaults to None. required send_data ( self , tag , message ) Broadcasts data from the ZMQ PUB socket. This function broadcasts data in the format of a python dictionary. The data is tagged with the specified label when broadcast. Parameters: Name Type Description Default tag str The label that will be attached to the data. required message Dict[str, Any] A dictionary, where the keys are names of information elements to be broadcasted through the broadcasting socket, and the corresponding values are the information elements to be sent (python objects). required ZmqResponder See documentation of the __init__ function. __init__ ( self , url ) special ZMQ-based responding socket for OnDA Monitors. This class implements a ZMQ REP socket that an OnDA Monitor can use to respond to requests from an external program. The responding socket can receive requests from ZMQ REQ sockets and send, in response, data in the format of a python dictionary. Parameters: Name Type Description Default url Optional[str] The URL where the socket will be opened. It must be a string in the format used by ZeroMQ, or None. If the value of this argument is None, the IP address of the local machine will be autodetected, and the socket will be opened at port 12322 using the 'tcp://' protocol. Defaults to None. required get_request ( self ) Gets a request from the ZMQ REP socket if present. This function checks if a request has been received by the responding socket. If the socket received a request, this function returns it. Otherwise the function returns None. This function is non-blocking. Returns: Type Description Optional[str] request: A string containing the request, or None if no request has been received by the socket. send_data ( self , message ) Send data from the ZMQ REP socket. This function sends data to an external program that has previously sent a request to the socket. The response must have the format of a python dictionary. Parameters: Name Type Description Default message Dict[str, Any] A dictionary containing information to be sent. required get_current_machine_ip () Retrieves the IP address of the local machine. This function uses the python 'socket' module to autodetect the IP addess of the the machine where it is invoked. Returns: Type Description str A string storing the IP address of the machine in the format XXX.XXX.XXX.XXX.","title":"zmq_monitor"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor","text":"ZMQ utilities to broadcast data from an OnDA Monitor. This module contains classes and functions that allow OnDA Monitors to broadcast data to external programs over a network connection.","title":"zmq_monitor"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor.ZmqDataBroadcaster","text":"See documentation of the __init__ function.","title":"ZmqDataBroadcaster"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor.ZmqDataBroadcaster.__init__","text":"ZMQ-based data-broadcasting socket for OnDA Monitors. This class implements a ZMQ PUB socket that can be used to broadcast data from an OnDA Monitor. The data must be tagged with a label when broadcast. The socket supports multiple simultaneous clients, but has no queuing system: broadcast data will be lost to the clients if not received before the next transmission takes place. Parameters: Name Type Description Default url Optional[str] The URL where the socket will be opened. It must be a string in the format used by ZeroMQ, or None. If the value of this argument is None, the IP address of the local machine will be autodetected, and the socket will be opened at port 12321 using the 'tcp://' protocol. Defaults to None. required","title":"__init__()"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor.ZmqDataBroadcaster.send_data","text":"Broadcasts data from the ZMQ PUB socket. This function broadcasts data in the format of a python dictionary. The data is tagged with the specified label when broadcast. Parameters: Name Type Description Default tag str The label that will be attached to the data. required message Dict[str, Any] A dictionary, where the keys are names of information elements to be broadcasted through the broadcasting socket, and the corresponding values are the information elements to be sent (python objects). required","title":"send_data()"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor.ZmqResponder","text":"See documentation of the __init__ function.","title":"ZmqResponder"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor.ZmqResponder.__init__","text":"ZMQ-based responding socket for OnDA Monitors. This class implements a ZMQ REP socket that an OnDA Monitor can use to respond to requests from an external program. The responding socket can receive requests from ZMQ REQ sockets and send, in response, data in the format of a python dictionary. Parameters: Name Type Description Default url Optional[str] The URL where the socket will be opened. It must be a string in the format used by ZeroMQ, or None. If the value of this argument is None, the IP address of the local machine will be autodetected, and the socket will be opened at port 12322 using the 'tcp://' protocol. Defaults to None. required","title":"__init__()"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor.ZmqResponder.get_request","text":"Gets a request from the ZMQ REP socket if present. This function checks if a request has been received by the responding socket. If the socket received a request, this function returns it. Otherwise the function returns None. This function is non-blocking. Returns: Type Description Optional[str] request: A string containing the request, or None if no request has been received by the socket.","title":"get_request()"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor.ZmqResponder.send_data","text":"Send data from the ZMQ REP socket. This function sends data to an external program that has previously sent a request to the socket. The response must have the format of a python dictionary. Parameters: Name Type Description Default message Dict[str, Any] A dictionary containing information to be sent. required","title":"send_data()"},{"location":"reference/om/utils/zmq_monitor/#om.utils.zmq_monitor.get_current_machine_ip","text":"Retrieves the IP address of the local machine. This function uses the python 'socket' module to autodetect the IP addess of the the machine where it is invoked. Returns: Type Description str A string storing the IP address of the machine in the format XXX.XXX.XXX.XXX.","title":"get_current_machine_ip()"}]}